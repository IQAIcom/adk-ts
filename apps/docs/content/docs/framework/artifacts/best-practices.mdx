---
title: Best Practices
description: Performance, security, versioning, and production considerations for artifact management
---

import { Callout } from 'fumadocs-ui/components/callout';

This guide covers essential best practices for using artifacts effectively in development and production. The emphasis is on clarity, safety, and maintainability.

## Choose the right service

Use the in-memory service for local dev and tests. Use GCS (or another durable backend) for production.

<Callout type="info">In-memory data is lost on restart. GCS persists and scales.</Callout>

## Filenames and MIME types

Use descriptive filenames (extensions help humans). Always set an accurate MIME type; consumers rely on it to decode data correctly.

```typescript
// Good: descriptive name + accurate type
await ctx.saveArtifact('monthly_report.pdf', {
  inlineData: { data: pdfBytesB64, mimeType: 'application/pdf' }
});

// Avoid: misleading extension or missing mimeType
// await ctx.saveArtifact('file', { inlineData: { data: pdfBytesB64 } });
```

## Understand scoping

Default filenames are session-scoped. Prefix with `user:` for user-wide artifacts that span sessions, e.g., `user:settings.json`.

Use `user:` only for data that truly belongs to the user across conversations.

## Versioning behavior

Every save creates a new version (starting at 0). Loading without an explicit version returns the latest. If you need a historical copy, pass the version number.

```typescript
await ctx.saveArtifact('report.pdf', pdfPart);        // v0
await ctx.saveArtifact('report.pdf', updatedPdfPart); // v1
const v0 = await ctx.loadArtifact('report.pdf', 0);
const latest = await ctx.loadArtifact('report.pdf');
```

## Error handling

Handle missing services, missing artifacts, and storage errors (auth, permissions, network):

```typescript
try {
  const a = await ctx.loadArtifact('maybe_exists.txt');
  if (!a) {
    // handle not found
  }
} catch (e) {
  // handle storage/auth/network issues
}
```

## Size and performance

Be mindful of large payloads: cost, latency, memory. Prefer compression for large text/JSON and avoid unnecessarily large binary data in-memory.

Simple batching and lightweight caching can help:

```typescript
await Promise.all([
  ctx.saveArtifact('a.txt', a),
  ctx.saveArtifact('b.txt', b)
]);
```

## Cleanup strategies

Durable stores like GCS keep artifacts until deleted. Consider:

- GCS lifecycle rules for automatic pruning
- Administrative tooling calling `deleteArtifact` for temporary data
- Naming conventions that distinguish temporary vs. long-lived artifacts

## Security basics

```typescript
// Validate filename, size, and MIME type before saving
const ALLOWED = new Set(['text/plain','text/csv','application/json','image/png','image/jpeg','application/pdf']);
const MAX = 50 * 1024 * 1024; // 50MB

function validatePart(filename: string, part: Part) {
  const mime = part.inlineData.mimeType;
  const size = Buffer.from(part.inlineData.data, 'base64').length;
  if (!/^[a-zA-Z0-9._-]+$/.test(filename.replace('user:', ''))) throw new Error('Invalid filename');
  if (!ALLOWED.has(mime)) throw new Error(`Unsupported MIME: ${mime}`);
  if (size > MAX) throw new Error(`File too large: ${size}`);
}
```

## Production Deployment Checklist

### Infrastructure Setup

- **Storage Backend**: Choose appropriate service (GCS, S3, database)
- **Backup Strategy**: Implement automated backups
- **Monitoring**: Set up metrics and alerting
- **Security**: Configure proper access controls and encryption
- **Rate Limiting**: Implement rate limiting to prevent abuse

### Configuration

- **Size Limits**: Set appropriate file size limits
- **MIME Types**: Whitelist allowed file types
- **Retention Policies**: Configure version cleanup
- **Caching**: Implement caching layer for performance
- **Error Handling**: Add comprehensive error handling

### Operational Procedures

- **Monitoring Dashboard**: Set up artifact usage monitoring
- **Backup Verification**: Test backup and restore procedures
- **Incident Response**: Document artifact-related incident procedures
- **Capacity Planning**: Monitor storage growth and plan scaling
- **Security Audits**: Regular security reviews of artifact access

<Callout type="warning">
Always test artifact operations thoroughly in staging environments before deploying to production.
</Callout>