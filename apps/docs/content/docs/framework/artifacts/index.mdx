---
title: Artifacts
description: Manage named, versioned binary data for rich agent interactions with files and media
---

import { Cards, Card } from 'fumadocs-ui/components/card';
import { Callout } from 'fumadocs-ui/components/callout';

Artifacts provide a mechanism for managing named, versioned binary data associated with user sessions or persistently with a user. They enable agents to handle data beyond simple text strings, supporting rich interactions with files, images, audio, and other binary formats.

## What are artifacts?

Artifacts are pieces of binary data (like files) identified by a unique filename within a scope (session or user). Each time you save an artifact with the same filename, a new numeric version is created automatically.

Representation:

- Standard data shape is a `Part` from `@google/genai` with `inlineData`:
  - `inlineData.data`: base64-encoded bytes
  - `inlineData.mimeType`: MIME type string (for correct interpretation)

## Why use artifacts

- Handle non-textual data (images, audio, PDFs, spreadsheets, etc.)
- Persist larger blobs separate from lightweight session state
- Manage user uploads and generated outputs across steps/sessions
- Share or cache binary results to avoid recomputation

<Callout type="info" title="Beyond Text Storage">
While session state is perfect for configuration and conversational context, artifacts are designed for binary data, large files, and content that needs versioning.
</Callout>

## Common use cases

- Generated reports/files (PDFs, CSV exports, image charts)
- Handling user uploads (analysis, summarization, conversion)
- Intermediate binary results in multi-step workflows (audio, renders)
- Persistent user data that isn’t a simple key-value
- Caching expensive binary outputs for reuse

## Quick Start

### Basic Artifact Operations

Here's how to work with artifacts in your agent callbacks:

```typescript
import { LlmAgent, CallbackContext, Runner } from '@iqai/adk';
import { InMemoryArtifactService } from '@iqai/adk';

// Set up artifact service
const artifactService = new InMemoryArtifactService();

// Use artifacts in callbacks
const beforeAgentCallback = async (callbackContext: CallbackContext) => {
  try {
    // Save a simple text artifact
    const textArtifact = {
      inlineData: {
        data: Buffer.from('Hello, World!').toString('base64'),
        mimeType: 'text/plain'
      }
    };

    const version = await callbackContext.saveArtifact('greeting.txt', textArtifact);
    console.log(`Saved greeting.txt version ${version}`);

    // Load an existing artifact
    const loadedArtifact = await callbackContext.loadArtifact('greeting.txt');
    if (loadedArtifact) {
      const text = Buffer.from(loadedArtifact.inlineData.data, 'base64').toString();
      console.log(`Loaded text: ${text}`);
    }
  } catch (error) {
    console.warn('Artifact operation failed:', error);
  }

  return undefined;
};

// Create agent with artifact service
const agent = new LlmAgent({
  name: "artifact_agent",
  model: "gemini-2.5-flash",
  description: "Agent that works with artifacts",
  instruction: "You are helpful",
  beforeAgentCallback
});

// Create runner with artifact service
const runner = new Runner({
  appName: "my_app",
  agent,
  sessionService: new InMemorySessionService(),
  artifactService // Configure artifact service
});
```

### Auto-save input blobs from user messages

When enabled, the runner will automatically save any incoming `inlineData` parts from the user's message as artifacts before appending the event. Each saved file is named using the pattern `artifact_<invocationId>_<index>` and the corresponding message part is replaced with a short text placeholder.

- Requires an `artifactService` to be configured on the `Runner`
- Toggle via `runConfig.saveInputBlobsAsArtifacts`
- Can be set at agent build time using `withRunConfig` or per run

```typescript
import { agentBuilder, Runner, InMemorySessionService, InMemoryArtifactService } from '@iqai/adk';

// Configure at agent build time
const agent = agentBuilder()
  .name('artifact_agent')
  .model('gemini-2.5-flash')
  .withRunConfig({ saveInputBlobsAsArtifacts: true })
  .build();

const runner = new Runner({
  appName: 'my_app',
  agent,
  sessionService: new InMemorySessionService(),
  artifactService: new InMemoryArtifactService(),
});

// Or enable per run
// await runner.runAsync({ userId, sessionId, newMessage, runConfig: new RunConfig({ saveInputBlobsAsArtifacts: true }) });
```

## Artifact Scoping

Artifacts can be scoped to different access levels:

### Session-Specific Artifacts

Artifacts tied to individual conversation sessions:

```typescript
// Regular filename - session scoped
await callbackContext.saveArtifact('temp_processing.csv', csvArtifact);
```

**Characteristics:**
- Limited to current session context
- Automatically cleaned up when sessions end
- Ideal for temporary processing and conversation-specific files

### User-Specific Artifacts

Artifacts persisting across all user sessions:

```typescript
// "user:" prefix - user scoped
await callbackContext.saveArtifact('user:profile_picture.png', imageArtifact);
```

**Characteristics:**
- Available across all user sessions within the application
- Persist beyond individual conversations
- Enable long-term user data management

<Callout type="warning" title="Namespace Selection">
Choose appropriate artifact scoping based on data lifecycle requirements - session for temporary content, user for persistent data.
</Callout>

## Versioning System

Artifacts automatically maintain version history:

```typescript
const versioningExample = async (callbackContext: CallbackContext) => {
  // First save - creates version 0
  const v0 = await callbackContext.saveArtifact('document.txt', textArtifact1);
  console.log(`Version: ${v0}`); // 0

  // Second save - creates version 1
  const v1 = await callbackContext.saveArtifact('document.txt', textArtifact2);
  console.log(`Version: ${v1}`); // 1

  // Load specific version
  const oldVersion = await callbackContext.loadArtifact('document.txt', 0);

  // Load latest version (default)
  const latestVersion = await callbackContext.loadArtifact('document.txt');

  return undefined;
};
```

**Version Characteristics:**
- Version numbers start at 0 and increment automatically
- Each save operation creates a new version
- Access latest version by default or specify version explicitly
- Complete version history maintained

## Where to start

<Cards>
  <Card
    title="Runner Configuration"
    description="Enable auto-save of uploads and wire services"
    href="/docs/framework/artifacts/runner-configuration"
  />
  <Card
    title="Using in Contexts"
    description="Save/load via CallbackContext and ToolContext"
    href="/docs/framework/artifacts/context-integration"
  />
  <Card
    title="Scoping & Versioning"
    description="Session vs user filenames and version behavior"
    href="/docs/framework/artifacts/scoping-and-versioning"
  />
  <Card
    title="Service Implementations"
    description="In-memory vs GCS and setup notes"
    href="/docs/framework/artifacts/service-implementations"
  />
  <Card
    title="Recipes"
    description="Upload → process → save, media, caching"
    href="/docs/framework/artifacts/recipes"
  />
  <Card
    title="Troubleshooting"
    description="Quick fixes for common issues"
    href="/docs/framework/artifacts/troubleshooting"
  />
  <Card
    title="Best Practices"
    description="Performance, security, and ops guidance"
    href="/docs/framework/artifacts/best-practices"
  />
</Cards>
## Related topics

See these pages for details and examples:

- Context usage: save/load/list via `CallbackContext` and `ToolContext`
- Scoping & versioning rules and patterns
- Service implementations (In-memory, GCS) and setup
- Recipes for upload → process → save and caching