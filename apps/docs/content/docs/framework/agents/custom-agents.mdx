---
title: Custom Agents
description: Build agents with completely custom orchestration logic
---

import { Callout } from "fumadocs-ui/components/callout";
import { Cards, Card } from "fumadocs-ui/components/card";

<Callout type="warn" title="Important">
  Building custom agents by implementing `runAsyncImpl` provides powerful
  control but requires understanding foundational concepts. We recommend
  mastering [LLM agents](/docs/framework/agents/llm-agents) and [workflow
  agents](/docs/framework/agents/workflow-agents) before tackling custom
  orchestration logic.
</Callout>

As your agentic applications grow in sophistication, you may find that the standard workflow patterns (SequentialAgent, ParallelAgent, LoopAgent) don't cover your specific orchestration needs. Custom agents fill this gap by giving you complete control over agent coordination and execution flow.

### What is a Custom Agent?

A custom agent is any class that inherits from `BaseAgent` and implements its core execution logic within the `runAsyncImpl` method. You have complete control over how this method calls other agents, manages state, handles errors, and coordinates complex workflows.

<Callout type="info" title="Method Name Note">
  The core method is `runAsyncImpl` in TypeScript. Other ADK languages may use
  different names (e.g., `_run_async_impl` in Python). Check your language's API
  documentation for specifics.
</Callout>

### Why Use Custom Agents?

While standard workflow agents cover common orchestration patterns, you need custom agents when your requirements include:

**üîÄ Conditional Logic**  
Execute different sub-agents or take different paths based on runtime conditions or previous step results

**üß† Dynamic Agent Selection**  
Choose which sub-agent(s) to run next based on dynamic evaluation of the situation or input analysis

**üîÑ Complex State Management**  
Implement intricate logic for maintaining and updating state throughout workflows beyond simple sequential passing

**üåê External Integrations**  
Incorporate calls to external APIs, databases, or custom libraries directly within orchestration flow control

**‚ö° Unique Workflow Patterns**  
Implement orchestration logic that doesn't fit standard sequential, parallel, or loop structures

**üõ°Ô∏è Advanced Error Handling**  
Custom retry logic, fallback strategies, and recovery mechanisms specific to your domain

## Implementing Custom Logic

### The runAsyncImpl Method

The heart of every custom agent is the `runAsyncImpl` method where you define unique orchestration behavior:

```typescript
protected async *runAsyncImpl(ctx: InvocationContext): AsyncIterator<Event>
```

**Key Properties:**

- **Signature**: Must be an `async *` function (AsyncGenerator)
- **Parameter**: `InvocationContext` provides access to session state, user context, and services
- **Return Type**: `AsyncIterator<Event>` enables streaming and backpressure handling
- **Event Yielding**: Must yield `Event` objects from sub-agents or custom progress updates

**Core Capabilities Within runAsyncImpl:**

```typescript
export class SimpleCustomAgent extends BaseAgent {
  private processor: LlmAgent;

  constructor() {
    super({
      name: "simple-custom-agent",
      description: "Demonstrates basic custom agent patterns",
    });

    this.processor = new LlmAgent({
      name: "content-processor",
      instruction: "Process the input content",
      outputKey: "processed_result",
    });
  }

  protected async *runAsyncImpl(ctx: InvocationContext): AsyncIterator<Event> {
    // 1. Read from session state to make decisions
    const userLevel = ctx.session.state.get("user_level", "standard");

    // 2. Yield progress events for user feedback
    yield new Event({
      author: this.name,
      content: { parts: [{ text: "üöÄ Starting custom processing..." }] },
    });

    // 3. Conditional logic - this is what makes it "custom"
    if (userLevel === "expert") {
      yield new Event({
        author: this.name,
        content: { parts: [{ text: "üë®‚Äçüíº Expert mode processing..." }] },
      });
      // Enhanced processing for experts
    }

    // 4. Call sub-agents and yield their events
    for await (const event of this.processor.runAsync(ctx)) {
      yield event; // Forward events from sub-agent
    }

    // 5. Update session state for downstream processes
    ctx.session.state.set("processing_complete", true);

    // 6. Final completion event
    yield new Event({
      author: this.name,
      content: { parts: [{ text: "‚úÖ Custom processing complete!" }] },
    });
  }
}
```

### Managing Sub-Agents and State

Custom agents typically orchestrate multiple sub-agents stored as instance properties. The framework needs to know about these relationships for lifecycle management and introspection.

#### Sub-Agent Initialization

Store and initialize sub-agents as instance properties for lifecycle management and introspection.

```typescript
export class WorkflowController extends BaseAgent {
  // Store sub-agents as instance properties
  private analyzer: LlmAgent;
  private validator: LlmAgent;
  private processor: LlmAgent;

  constructor() {
    super({
      name: "workflow-controller",
      description: "Custom workflow orchestration",
    });

    // Initialize sub-agents in constructor
    this.analyzer = new LlmAgent({
      name: "content-analyzer",
      instruction: "Analyze content complexity and type",
      outputKey: "analysis_result",
    });

    this.validator = new LlmAgent({
      name: "content-validator",
      instruction: "Validate content meets requirements",
      outputKey: "validation_status",
    });

    this.processor = new LlmAgent({
      name: "content-processor",
      instruction: "Process content based on {analysis_result}",
      outputKey: "final_result",
    });
  }

  protected async *runAsyncImpl(ctx: InvocationContext): AsyncIterator<Event> {
    // Your custom orchestration logic here
  }
}
```

#### State Management Patterns

Coordinate agent decisions and data flow through session state with proper defaults and validation.

```typescript
protected async *runAsyncImpl(ctx: InvocationContext): AsyncIterator<Event> {
  // Reading state with defaults
  const userPreferences = ctx.session.state.get("user_preferences", {});
  const contentType = ctx.session.state.get("content_type", "general");

  // Making decisions based on state
  if (contentType === "technical" && userPreferences.detail_level === "high") {
    yield* this.handleTechnicalContent(ctx);
  } else {
    yield* this.handleGeneralContent(ctx);
  }

  // Setting state for downstream agents
  ctx.session.state.set("processing_stage", "validation");
  ctx.session.state.set("workflow_metadata", {
    started_at: new Date().toISOString(),
    content_type: contentType
  });

  // State updates through events (recommended for auditability)
  yield new Event({
    author: this.name,
    content: { parts: [{ text: "Analysis phase complete" }] },
    actions: new EventActions({
      stateDelta: {
        analysis_complete: true,
        confidence_score: 0.92
      }
    })
  });
}
```

#### State Template Integration

Enable sub-agents to dynamically access session state through template variables in their instructions.

```typescript
const processor = new LlmAgent({
  name: "adaptive-processor",
  instruction: `
    Process content with complexity: {complexity_level}
    User preferences: {user_preferences}
    Processing mode: {processing_mode}
  `,
  outputKey: "processed_content",
});
```

## Design Pattern Example: ContentWorkflowAgent

Let's build a comprehensive example showing advanced custom agent patterns: a content generation system with conditional refinement, quality gates, and regeneration logic.

**Goal**: Create a system that generates content, iteratively refines it through critique, validates quality, and regenerates if quality standards aren't met.

**Why Custom**: The conditional regeneration based on quality validation requires custom logic that standard workflow agents cannot provide.

### Step 1: Agent Structure and Initialization

We'll build a content workflow agent that demonstrates all key custom agent concepts:

```typescript
import {
  BaseAgent,
  InvocationContext,
  Event,
  EventActions,
  LlmAgent,
  LoopAgent,
  SequentialAgent
} from "@iqai/adk";

export class ContentWorkflowAgent extends BaseAgent {
  // Declare sub-agents as instance properties
  private contentGenerator: LlmAgent;
  private contentCritic: LlmAgent;
  private contentReviser: LlmAgent;
  private qualityChecker: LlmAgent;
  private toneAnalyzer: LlmAgent;

  // Workflow orchestrators
  private critiqueLoop: LoopAgent;
  private qualityValidation: SequentialAgent;

  constructor() {
    super({
      name: "content-workflow-agent",
      description: "Advanced content generation with quality control"
    });

    // Initialize individual specialist agents
    this.contentGenerator = new LlmAgent({
      name: "content-generator",
      model: "gemini-2.5-flash",
      instruction: "Generate engaging content on topic: {content_topic}",
      outputKey: "current_content"
    });

    this.contentCritic = new LlmAgent({
      name: "content-critic",
      model: "gemini-2.5-flash",
      instruction: "Review content: {current_content}. Provide specific improvement suggestions.",
      outputKey: "critique_feedback"
    });

    this.contentReviser = new LlmAgent({
      name: "content-reviser",
      model: "gemini-2.5-flash",
      instruction: "Revise content: {current_content} based on: {critique_feedback}",
      outputKey: "current_content" // Overwrites previous content
    });

    this.qualityChecker = new LlmAgent({
      name: "quality-checker",
      model: "gemini-2.5-flash",
      instruction: "Rate content quality 1-10: {current_content}. Output only the number.",
      outputKey: "quality_score"
    });

    this.toneAnalyzer = new LlmAgent({
      name: "tone-analyzer",
      model: "gemini-2.5-flash",
      instruction: "Analyze tone: {current_content}. Output: 'positive', 'negative', or 'neutral'.",
      outputKey: "tone_result"
    });

    // Create workflow orchestrators that we'll use in custom logic
    this.critiqueLoop = new LoopAgent({
      name: "critique-loop",
      maxIterations: 2,
      subAgents: [this.contentCritic, this.contentReviser]
    });

    this.qualityValidation = new SequentialAgent({
      name: "quality-validation",
      subAgents: [this.qualityChecker, this.toneAnalyzer]
    });
  }
```

### Step 2: Custom Orchestration Logic

Now we implement the custom logic that makes this agent unique:

```typescript
  protected async *runAsyncImpl(ctx: InvocationContext): AsyncIterator<Event> {
    const maxRegenerations = 2;
    let regenerationCount = 0;

    yield new Event({
      author: this.name,
      content: { parts: [{ text: "üöÄ Starting content workflow..." }] }
    });

    // Main processing loop with quality-based regeneration
    while (regenerationCount <= maxRegenerations) {
      // Step 1: Generate content
      yield new Event({
        author: this.name,
        content: {
          parts: [{
            text: regenerationCount === 0
              ? "üìù Generating initial content..."
              : `üîÑ Regeneration attempt ${regenerationCount}...`
          }]
        }
      });

      for await (const event of this.contentGenerator.runAsync(ctx)) {
        yield event;
      }

      // Verify content was generated
      if (!ctx.session.state.get("current_content")) {
        yield new Event({
          author: this.name,
          content: { parts: [{ text: "‚ùå Content generation failed" }] }
        });
        return;
      }

      // Step 2: Iterative refinement using LoopAgent
      yield new Event({
        author: this.name,
        content: { parts: [{ text: "üîç Starting critique and revision..." }] }
      });

      for await (const event of this.critiqueLoop.runAsync(ctx)) {
        yield event;
      }

      // Step 3: Quality validation using SequentialAgent
      yield new Event({
        author: this.name,
        content: { parts: [{ text: "‚úÖ Validating content quality..." }] }
      });

      for await (const event of this.qualityValidation.runAsync(ctx)) {
        yield event;
      }

      // Step 4: Quality-based decision making (this is the custom part!)
      const qualityScore = parseInt(ctx.session.state.get("quality_score", "0"));
      const toneResult = ctx.session.state.get("tone_result", "neutral");
      const qualityThreshold = 7;

      yield new Event({
        author: this.name,
        content: {
          parts: [{
            text: `üìä Quality: ${qualityScore}/10, Tone: ${toneResult}`
          }]
        }
      });

      // Step 5: Custom workflow control
      if (qualityScore >= qualityThreshold && toneResult !== "negative") {
        // Success case
        yield new Event({
          author: this.name,
          content: { parts: [{ text: "üéâ Content approved!" }] },
          actions: new EventActions({
            stateDelta: {
              workflow_status: "completed",
              final_quality_score: qualityScore,
              regeneration_count: regenerationCount
            }
          })
        });
        return; // Exit successfully
      } else {
        // Quality insufficient - try regenerating
        regenerationCount++;

        if (regenerationCount > maxRegenerations) {
          yield new Event({
            author: this.name,
            content: {
              parts: [{
                text: `‚ö†Ô∏è Max regenerations reached. Final score: ${qualityScore}`
              }]
            }
          });
          return;
        }

        yield new Event({
          author: this.name,
          content: {
            parts: [{
              text: `üîÑ Quality below threshold. Regenerating...`
            }]
          }
        });
      }
    }
  }
}
```

### Step 3: Usage Example

```typescript
// Create and use the custom agent
const contentWorkflow = new ContentWorkflowAgent();

const result = await contentWorkflow.run({
  message: "Create content about sustainable technology",
  state: {
    content_topic: "sustainable technology innovations",
  },
});

// Check results
console.log("Status:", result.state.workflow_status);
console.log("Quality Score:", result.state.final_quality_score);
console.log("Regenerations:", result.state.regeneration_count);
```

### What Makes This Advanced

This example demonstrates sophisticated custom agent orchestration:

**üîÑ Quality-Based Loops**: Regenerates content until quality standards are met  
**üéØ Conditional Logic**: Different execution paths based on quality scores and tone  
**üèóÔ∏è Agent Composition**: Combines LoopAgent and SequentialAgent within custom logic  
**üìä Complex State Management**: Tracks metrics, counts, and completion status  
**‚ö° Early Termination**: Exits when success criteria met or max attempts reached  
**üîç Multi-Criteria Evaluation**: Considers both quality score and tone for decisions

## Building Custom Logic

### Session State Management

Coordinate between agents and make decisions based on previous results. See [Sessions & State](/docs/framework/sessions) for detailed state management patterns.

```typescript
protected async *runAsyncImpl(ctx: InvocationContext) {
  // Read previous results
  const userPrefs = ctx.session.state.get("user_preferences", {});
  const previousAnalysis = ctx.session.state.get("analysis_results");

  // Make decisions based on state
  if (previousAnalysis?.complexity === "high") {
    yield* this.handleComplexCase(ctx);
  }

  // Save results for next steps
  ctx.session.state.set("processing_stage", "analysis_complete");
  ctx.session.state.set("confidence_score", 0.92);
}
```

### Conditional Agent Orchestration

Route to different agents based on runtime analysis - context, user preferences, or data characteristics. This enables dynamic processing paths beyond fixed [workflow patterns](/docs/framework/agents/workflow-agents).

```typescript
protected async *runAsyncImpl(ctx: InvocationContext) {
  const inputType = this.analyzeInputType(ctx.session.state.get("user_input"));

  // Route to appropriate specialist
  let selectedAgent;
  switch (inputType) {
    case "technical":
      selectedAgent = this.findAgent("technical-specialist");
      break;
    case "creative":
      selectedAgent = this.findAgent("creative-specialist");
      break;
    default:
      selectedAgent = this.findAgent("general-processor");
  }

  // Execute selected agent
  if (selectedAgent) {
    for await (const event of selectedAgent.runAsync(ctx)) {
      yield event;
    }
  }
}
```

### External Service Integration

Connect with external APIs, databases, or services to fetch data, validate information, or trigger external actions.

```typescript
protected async *runAsyncImpl(ctx: InvocationContext) {
  // Use framework services if available
  if (ctx.memoryService) {
    const memories = await ctx.memoryService.searchMemory({
      query: "relevant context",
      appName: ctx.appName,
      userId: ctx.userId
    });
  }

  // Call external APIs
  try {
    const response = await fetch('https://api.example.com/data');
    const externalData = await response.json();

    // Use the data in your logic
    ctx.session.state.set("external_data", externalData);

    yield new Event({
      author: this.name,
      content: { parts: [{ text: "External data retrieved successfully" }] }
    });
  } catch (error) {
    yield new Event({
      author: this.name,
      content: { parts: [{ text: "Failed to retrieve external data, using fallback" }] }
    });
  }
}
```

## Advanced Patterns

### State Machine Pattern

Implement workflows with distinct phases and transition rules. Ideal for approval processes, multi-stage processing, or any workflow requiring progress tracking through defined states.

```typescript
protected async *runAsyncImpl(ctx: InvocationContext) {
  let currentState = ctx.session.state.get("workflow_state", "initialized");

  while (currentState !== "completed") {
    yield new Event({
      author: this.name,
      content: { parts: [{ text: `Processing state: ${currentState}` }] }
    });

    switch (currentState) {
      case "initialized":
        currentState = await this.handleInitialization(ctx);
        break;
      case "analyzing":
        currentState = await this.handleAnalysis(ctx);
        break;
      case "processing":
        currentState = await this.handleProcessing(ctx);
        break;
      case "validating":
        currentState = await this.handleValidation(ctx);
        break;
      default:
        currentState = "error";
    }

    ctx.session.state.set("workflow_state", currentState);
  }
}
```

### Dynamic Agent Selection

Select agents based on runtime analysis rather than hardcoded paths. Create adaptive systems that route to specialists or adjust processing based on complexity, user tier, or system state.

```typescript
private selectOptimalAgent(ctx: InvocationContext): BaseAgent {
  const complexity = this.analyzeComplexity(ctx.session.state.get("user_input", ""));
  const userTier = ctx.session.state.get("user_tier", "basic");

  // Route based on complexity and user tier
  if (complexity > 0.8 && userTier === "premium") {
    return this.findAgent("expert-specialist");
  } else if (complexity > 0.5) {
    return this.findAgent("intermediate-processor");
  } else {
    return this.findAgent("basic-processor");
  }
}
```

### Error Handling and Recovery

Implement retry logic, graceful degradation, and fallback strategies when coordinating multiple systems and external services.

```typescript
protected async *runAsyncImpl(ctx: InvocationContext) {
  const maxRetries = 3;
  let attempt = 0;

  while (attempt < maxRetries) {
    try {
      yield* this.executeMainLogic(ctx);
      return; // Success - exit retry loop

    } catch (error) {
      attempt++;

      yield new Event({
        author: this.name,
        content: { parts: [{ text: `Attempt ${attempt} failed: ${(error as Error).message}` }] }
      });

      if (attempt < maxRetries) {
        yield new Event({
          author: this.name,
          content: { parts: [{ text: `Retrying in 2 seconds... (${attempt}/${maxRetries})` }] }
        });

        await new Promise(resolve => setTimeout(resolve, 2000));
      } else {
        // Final attempt failed - try fallback
        yield new Event({
          author: this.name,
          content: { parts: [{ text: "All attempts failed, switching to fallback method" }] }
        });

        yield* this.executeFallbackLogic(ctx);
      }
    }
  }
}
```

## Event Communication

### Progress Events

Provide regular feedback during long-running operations. See [Events](/docs/framework/events) for detailed event patterns.

```typescript
protected async *runAsyncImpl(ctx: InvocationContext) {
  const totalSteps = 5;

  for (let step = 1; step <= totalSteps; step++) {
    yield new Event({
      author: this.name,
      content: { parts: [{ text: `Step ${step}/${totalSteps}: Processing...` }] },
      metadata: { progress: step / totalSteps }
    });

    // Execute step logic
    await this.executeStep(step, ctx);
  }
}
```

### State Updates

Update session state through EventActions for better auditability and transparency. See [EventActions](/docs/framework/events#event-actions) for complete API reference.

```typescript
yield new Event({
  author: this.name,
  content: { parts: [{ text: "Analysis complete" }] },
  actions: new EventActions({
    stateDelta: {
      analysis_results: analysisData,
      confidence_score: 0.95,
      next_recommended_action: "proceed_to_synthesis",
    },
  }),
});
```

### Agent Transfer

Delegate control to specialized agents or escalate to supervisors while maintaining conversation flow.

```typescript
// Conditional transfer based on analysis
if (requiresSpecialistReview) {
  yield new Event({
    author: this.name,
    content: {
      parts: [{ text: "Transferring to specialist for expert review" }],
    },
    actions: new EventActions({
      transferToAgent: "specialist-reviewer",
    }),
  });
}
```

## Advanced Concepts

### Workflow State Machines

Implement complex workflows with explicit state transitions, validation, and rollback capabilities:

```typescript
type WorkflowState =
  | "initialized"
  | "analyzing"
  | "processing"
  | "validating"
  | "completed"
  | "failed";

export class WorkflowStateMachine extends BaseAgent {
  private readonly stateTransitions: Record<WorkflowState, WorkflowState[]> = {
    initialized: ["analyzing", "failed"],
    analyzing: ["processing", "failed"],
    processing: ["validating", "failed"],
    validating: ["completed", "processing", "failed"], // Can retry processing
    completed: [],
    failed: ["initialized"], // Can restart
  };

  protected async *runAsyncImpl(ctx: InvocationContext): AsyncIterator<Event> {
    let currentState: WorkflowState = ctx.session.state.get(
      "workflow_state",
      "initialized"
    );

    while (currentState !== "completed" && currentState !== "failed") {
      const nextState = await this.executeStateLogic(currentState, ctx);

      if (!this.isValidTransition(currentState, nextState)) {
        throw new Error(
          `Invalid state transition: ${currentState} -> ${nextState}`
        );
      }

      yield new Event({
        author: this.name,
        content: {
          parts: [{ text: `State transition: ${currentState} ‚Üí ${nextState}` }],
        },
        actions: new EventActions({
          stateDelta: {
            workflow_state: nextState,
            state_transition_time: new Date().toISOString(),
          },
        }),
      });

      currentState = nextState;
    }
  }

  private isValidTransition(from: WorkflowState, to: WorkflowState): boolean {
    return this.stateTransitions[from].includes(to);
  }
}
```

### Hierarchical Agent Management

Build complex agent hierarchies with proper lifecycle management and resource cleanup:

```typescript
export class AgentSupervisor extends BaseAgent {
  private childAgents = new Map<string, BaseAgent>();
  private activeExecutions = new Set<string>();

  constructor() {
    super({
      name: "agent-supervisor",
      description:
        "Manages hierarchical agent execution with lifecycle control",
    });
  }

  protected async *runAsyncImpl(ctx: InvocationContext): AsyncIterator<Event> {
    try {
      // Initialize child agents dynamically
      const requiredAgents = this.determineRequiredAgents(ctx);

      for (const agentSpec of requiredAgents) {
        const agent = this.createAgent(agentSpec);
        this.childAgents.set(agentSpec.id, agent);
      }

      // Execute agents with proper supervision
      yield* this.executeWithSupervision(ctx);
    } finally {
      // Cleanup resources
      await this.cleanupChildAgents();
    }
  }

  private async *executeWithSupervision(
    ctx: InvocationContext
  ): AsyncIterator<Event> {
    const maxConcurrent = 3;
    const pending: Promise<void>[] = [];

    for (const [agentId, agent] of this.childAgents) {
      if (pending.length >= maxConcurrent) {
        await Promise.race(pending);
        pending.splice(
          pending.findIndex((p) => p),
          1
        );
      }

      const execution = this.executeChildAgent(agentId, agent, ctx);
      pending.push(execution);
      this.activeExecutions.add(agentId);
    }

    // Wait for all remaining executions
    await Promise.all(pending);
  }

  private async executeChildAgent(
    agentId: string,
    agent: BaseAgent,
    ctx: InvocationContext
  ): Promise<void> {
    try {
      for await (const event of agent.runAsync(ctx)) {
        // Add supervision metadata
        const supervisedEvent = new Event({
          ...event,
          metadata: {
            ...event.metadata,
            supervised_by: this.name,
            child_agent_id: agentId,
          },
        });
        // Event would be yielded in actual implementation
      }
    } finally {
      this.activeExecutions.delete(agentId);
    }
  }
}
```

### Resource Management and Concurrency Control

Implement sophisticated resource management for agents that coordinate expensive operations:

```typescript
export class ResourceManagedAgent extends BaseAgent {
  private readonly resourcePool = new Map<
    string,
    { inUse: boolean; resource: any }
  >();
  private readonly maxConcurrentOperations = 5;
  private currentOperations = 0;

  protected async *runAsyncImpl(ctx: InvocationContext): AsyncIterator<Event> {
    const resourceId = await this.acquireResource();

    try {
      yield new Event({
        author: this.name,
        content: { parts: [{ text: `üîí Acquired resource: ${resourceId}` }] },
      });

      yield* this.executeWithResource(resourceId, ctx);
    } finally {
      this.releaseResource(resourceId);

      yield new Event({
        author: this.name,
        content: { parts: [{ text: `üîì Released resource: ${resourceId}` }] },
      });
    }
  }

  private async acquireResource(): Promise<string> {
    return new Promise((resolve) => {
      const checkResource = () => {
        if (this.currentOperations < this.maxConcurrentOperations) {
          this.currentOperations++;
          const resourceId = `resource_${Date.now()}_${Math.random()}`;
          this.resourcePool.set(resourceId, { inUse: true, resource: {} });
          resolve(resourceId);
        } else {
          setTimeout(checkResource, 100); // Check again in 100ms
        }
      };
      checkResource();
    });
  }

  private releaseResource(resourceId: string): void {
    this.resourcePool.delete(resourceId);
    this.currentOperations--;
  }
}
```

### Event-Driven Architecture

Build agents that respond to events and coordinate through message passing:

```typescript
interface AgentMessage {
  type: "request" | "response" | "notification";
  from: string;
  to: string;
  payload: any;
  correlationId?: string;
}

export class EventDrivenCoordinator extends BaseAgent {
  private messageQueue: AgentMessage[] = [];
  private responseHandlers = new Map<string, (message: AgentMessage) => void>();

  protected async *runAsyncImpl(ctx: InvocationContext): AsyncIterator<Event> {
    // Start message processing loop
    const messageProcessor = this.processMessages(ctx);

    // Send initial requests to child agents
    yield* this.initiateWorkflow(ctx);

    // Process messages until workflow complete
    for await (const event of messageProcessor) {
      yield event;

      const workflowComplete = ctx.session.state.get(
        "workflow_complete",
        false
      );
      if (workflowComplete) {
        break;
      }
    }
  }

  private async *processMessages(ctx: InvocationContext): AsyncIterator<Event> {
    while (true) {
      if (this.messageQueue.length > 0) {
        const message = this.messageQueue.shift()!;
        yield* this.handleMessage(message, ctx);
      }

      await new Promise((resolve) => setTimeout(resolve, 10)); // Prevent tight loop
    }
  }

  private async *handleMessage(
    message: AgentMessage,
    ctx: InvocationContext
  ): AsyncIterator<Event> {
    switch (message.type) {
      case "response":
        yield new Event({
          author: this.name,
          content: {
            parts: [{ text: `üì® Received response from ${message.from}` }],
          },
        });

        const handler = this.responseHandlers.get(message.correlationId!);
        if (handler) {
          handler(message);
          this.responseHandlers.delete(message.correlationId!);
        }
        break;

      case "notification":
        yield new Event({
          author: this.name,
          content: {
            parts: [{ text: `üîî Notification: ${message.payload.text}` }],
          },
        });
        break;
    }
  }

  private sendMessage(message: AgentMessage): void {
    this.messageQueue.push(message);
  }
}
```

### Agent Composition Patterns

Create sophisticated agent compositions that combine multiple orchestration strategies:

```typescript
export class HybridOrchestrator extends BaseAgent {
  private sequentialPhase: SequentialAgent;
  private parallelPhase: ParallelAgent;
  private customPhase: BaseAgent;

  constructor() {
    super({
      name: "hybrid-orchestrator",
      description:
        "Combines sequential, parallel, and custom orchestration patterns",
    });

    // Sequential initialization phase
    this.sequentialPhase = new SequentialAgent({
      name: "initialization-phase",
      description: "Sequential setup and validation",
      subAgents: [
        new LlmAgent({
          name: "validator",
          instruction: "Validate inputs",
          outputKey: "validation_result",
        }),
        new LlmAgent({
          name: "analyzer",
          instruction: "Analyze requirements",
          outputKey: "analysis_result",
        }),
      ],
    });

    // Parallel processing phase
    this.parallelPhase = new ParallelAgent({
      name: "processing-phase",
      description: "Concurrent data processing",
      subAgents: [
        new LlmAgent({
          name: "processor-a",
          instruction: "Process type A data",
          outputKey: "results_a",
        }),
        new LlmAgent({
          name: "processor-b",
          instruction: "Process type B data",
          outputKey: "results_b",
        }),
        new LlmAgent({
          name: "processor-c",
          instruction: "Process type C data",
          outputKey: "results_c",
        }),
      ],
    });

    // Custom synthesis phase
    this.customPhase = new (class extends BaseAgent {
      protected async *runAsyncImpl(
        ctx: InvocationContext
      ): AsyncIterator<Event> {
        const resultsA = ctx.session.state.get("results_a");
        const resultsB = ctx.session.state.get("results_b");
        const resultsC = ctx.session.state.get("results_c");

        // Custom synthesis logic
        const synthesized = this.synthesizeResults(
          resultsA,
          resultsB,
          resultsC
        );

        yield new Event({
          author: this.name,
          content: { parts: [{ text: "üîÑ Synthesizing parallel results..." }] },
          actions: new EventActions({
            stateDelta: { synthesized_results: synthesized },
          }),
        });
      }

      private synthesizeResults(a: any, b: any, c: any): any {
        // Custom synthesis logic here
        return { combined: [a, b, c], timestamp: new Date().toISOString() };
      }
    })();
  }

  protected async *runAsyncImpl(ctx: InvocationContext): AsyncIterator<Event> {
    // Phase 1: Sequential initialization
    yield new Event({
      author: this.name,
      content: {
        parts: [{ text: "üîÑ Phase 1: Sequential initialization..." }],
      },
    });

    for await (const event of this.sequentialPhase.runAsync(ctx)) {
      yield event;
    }

    // Check if initialization was successful
    const validationResult = ctx.session.state.get("validation_result");
    if (validationResult !== "valid") {
      yield new Event({
        author: this.name,
        content: {
          parts: [{ text: "‚ùå Initialization failed, aborting workflow" }],
        },
      });
      return;
    }

    // Phase 2: Parallel processing
    yield new Event({
      author: this.name,
      content: { parts: [{ text: "üîÑ Phase 2: Parallel processing..." }] },
    });

    for await (const event of this.parallelPhase.runAsync(ctx)) {
      yield event;
    }

    // Phase 3: Custom synthesis
    yield new Event({
      author: this.name,
      content: { parts: [{ text: "üîÑ Phase 3: Custom synthesis..." }] },
    });

    for await (const event of this.customPhase.runAsync(ctx)) {
      yield event;
    }

    yield new Event({
      author: this.name,
      content: {
        parts: [{ text: "‚úÖ Hybrid orchestration completed successfully" }],
      },
    });
  }
}
```

## Common Use Cases

### Business Process Automation

Create agents that mirror real business workflows:

- **Document Approval**: Route documents through different approval chains based on content, value, or department
- **Customer Support**: Triage support tickets and route to appropriate specialists
- **Content Moderation**: Apply different review processes based on content type and risk level

### Data Processing Pipelines

Build intelligent ETL workflows:

- **Data Validation**: Check data quality and route to appropriate cleaning processes
- **Format Conversion**: Convert between formats based on target system requirements
- **Data Enrichment**: Enhance data with external sources based on availability and relevance

### Decision Support Systems

Implement complex decision trees:

- **Risk Assessment**: Analyze multiple factors and escalate based on risk levels
- **Recommendation Engines**: Provide personalized recommendations based on user profiles
- **Resource Allocation**: Distribute work based on capacity, expertise, and priorities

## Testing Custom Agents

### Unit Testing

Test custom orchestration logic in isolation using mocked contexts and sub-agents:

```typescript
import { describe, it, expect, vi } from "vitest";

describe("ContentWorkflowAgent", () => {
  it("should regenerate content when quality is below threshold", async () => {
    const agent = new ContentWorkflowAgent();

    const mockContext = {
      session: {
        state: new Map([
          ["content_topic", "test topic"],
          ["quality_score", "5"], // Below threshold
          ["tone_result", "positive"],
        ]),
      },
    } as any;

    const events = [];
    for await (const event of agent.runAsync(mockContext)) {
      events.push(event);
    }

    // Should contain regeneration messages
    const regenerationEvents = events.filter((e) =>
      e.content?.parts[0]?.text?.includes("Regeneration attempt")
    );
    expect(regenerationEvents.length).toBeGreaterThan(0);
  });

  it("should skip regeneration for high quality content", async () => {
    const mockContext = {
      session: {
        state: new Map([
          ["content_topic", "test topic"],
          ["quality_score", "9"], // Above threshold
          ["tone_result", "positive"],
        ]),
      },
    } as any;

    const events = [];
    for await (const event of agent.runAsync(mockContext)) {
      events.push(event);
    }

    // Should contain approval message, no regeneration
    const approvalEvents = events.filter((e) =>
      e.content?.parts[0]?.text?.includes("Content approved")
    );
    expect(approvalEvents.length).toBeGreaterThan(0);
  });
});
```

### Integration Testing

Verify end-to-end workflows with real sub-agents and dependencies to ensure proper state flow and event generation:

```typescript
describe("Integration Tests", () => {
  it("should process documents end-to-end", async () => {
    const processor = new SmartDocumentProcessor();

    const result = await processor.run({
      message: "Analyze this document: [sample technical document]",
    });

    expect(result.session.state.get("processing_report")).toBeDefined();
    expect(result.session.state.get("executive_summary")).toBeDefined();
  });
});
```

### Performance Testing

Test execution times, resource usage, and behavior under load to identify bottlenecks in multi-agent orchestration:

```typescript
describe("Performance Tests", () => {
  it("should complete processing within acceptable time limits", async () => {
    const processor = new SmartDocumentProcessor();
    const startTime = Date.now();

    const result = await processor.run({
      message: "Process this large document: [large document content]",
    });

    const executionTime = Date.now() - startTime;
    expect(executionTime).toBeLessThan(30000); // Should complete within 30 seconds
  });

  it("should handle concurrent processing efficiently", async () => {
    const processor = new SmartDocumentProcessor();
    const concurrentRequests = 5;

    const startTime = Date.now();
    const promises = Array.from({ length: concurrentRequests }, (_, i) =>
      processor.run({
        message: `Process document ${i + 1}: [document content]`,
      })
    );

    const results = await Promise.all(promises);
    const totalTime = Date.now() - startTime;

    // All requests should complete
    expect(results).toHaveLength(concurrentRequests);
    results.forEach((result) => {
      expect(result.session.state.get("processing_report")).toBeDefined();
    });

    // Should be more efficient than sequential processing
    expect(totalTime).toBeLessThan(concurrentRequests * 10000); // Less than 10s per request
  });

  it("should not leak memory during repeated operations", async () => {
    const processor = new SmartDocumentProcessor();
    const initialMemory = process.memoryUsage().heapUsed;

    // Run multiple operations
    for (let i = 0; i < 10; i++) {
      await processor.run({
        message: `Process document ${i}: [document content]`,
      });
    }

    // Force garbage collection if available
    if (global.gc) {
      global.gc();
    }

    const finalMemory = process.memoryUsage().heapUsed;
    const memoryIncrease = finalMemory - initialMemory;

    // Memory increase should be reasonable (less than 50MB)
    expect(memoryIncrease).toBeLessThan(50 * 1024 * 1024);
  });

  it("should handle timeouts gracefully", async () => {
    const slowProcessor = new (class extends SmartDocumentProcessor {
      protected async *runAsyncImpl(ctx: InvocationContext) {
        // Simulate slow processing
        yield new Event({
          author: this.name,
          content: { parts: [{ text: "Starting slow processing..." }] },
        });

        await new Promise((resolve) => setTimeout(resolve, 5000)); // 5 second delay

        yield new Event({
          author: this.name,
          content: { parts: [{ text: "Processing complete" }] },
        });
      }
    })();

    // Test with timeout
    const timeoutPromise = new Promise((_, reject) =>
      setTimeout(() => reject(new Error("Timeout")), 3000)
    );

    const processingPromise = slowProcessor.run({
      message: "Process with timeout test",
    });

    await expect(
      Promise.race([processingPromise, timeoutPromise])
    ).rejects.toThrow("Timeout");
  });
});
```

## Best Practices

### Design Principles

<Callout type="info" title="Single Responsibility">
  Each custom agent should have one clear orchestration purpose. If your agent
  handles multiple unrelated workflows, consider splitting it into focused
  agents coordinated by a higher-level orchestrator.
</Callout>

**üéØ Clear Purpose**: Define a single, specific orchestration responsibility  
**üìä Explicit State**: Use descriptive state keys and document data flow  
**üîÑ Predictable Logic**: Make your conditional logic easy to understand and test  
**‚ö° Efficient Execution**: Skip unnecessary work and provide meaningful progress feedback  
**üõ°Ô∏è Robust Error Handling**: Plan for failures and implement graceful degradation

### Common Pitfalls

**‚ùå Avoid These Mistakes:**

```typescript
// Don't: Silent failures without user feedback
if (someCondition) {
  // Quietly skips processing
}

// Don't: Vague error messages
catch (error) {
  yield new Event({
    author: this.name,
    content: { parts: [{ text: "Error occurred" }] }
  });
}

// Don't: Unclear state management
ctx.session.state.set("data", someValue);
ctx.session.state.set("flag", true);
```

**‚úÖ Do This Instead:**

```typescript
// Do: Communicate all decisions
if (skipProcessing) {
  yield new Event({
    author: this.name,
    content: { parts: [{ text: "Skipping advanced processing - content complexity is low" }] }
  });
}

// Do: Specific error context
catch (error) {
  yield new Event({
    author: this.name,
    content: { parts: [{ text: `Content analysis failed: ${(error as Error).message}` }] }
  });
}

// Do: Descriptive state keys
ctx.session.state.set("analysis_results", analysisData);
ctx.session.state.set("requires_expert_review", needsReview);
```

### Progress Tracking

Provide meaningful user feedback during long operations:

```typescript
protected async *runAsyncImpl(ctx: InvocationContext): AsyncIterator<Event> {
  const totalSteps = 4;
  let currentStep = 0;

  const updateProgress = (stepName: string) => {
    currentStep++;
    return new Event({
      author: this.name,
      content: { parts: [{ text: `‚ö° Step ${currentStep}/${totalSteps}: ${stepName}` }] },
      metadata: { progress: currentStep / totalSteps }
    });
  };

  yield updateProgress("Analyzing input");
  for await (const event of this.analyzer.runAsync(ctx)) {
    yield event;
  }

  yield updateProgress("Processing content");
  for await (const event of this.processor.runAsync(ctx)) {
    yield event;
  }

  yield updateProgress("Validation");
  for await (const event of this.validator.runAsync(ctx)) {
    yield event;
  }

  yield updateProgress("Completion");
  // Final processing logic
}
```

## Related Topics

<Cards>
  <Card
    title="ü§ñ LLM Agents"
    description="The building blocks that custom agents orchestrate"
    href="/docs/framework/agents/llm-agents"
  />

<Card
  title="üîÑ Workflow Agents"
  description="Standard patterns to use before building custom logic"
  href="/docs/framework/agents/workflow-agents"
/>

<Card
  title="üì° Events & Actions"
  description="Communication system for agent coordination"
  href="/docs/framework/events"
/>

  <Card
    title="üß† Sessions & State"
    description="Managing data flow and persistence"
    href="/docs/framework/sessions"
  />
</Cards>
