---
title: Event System in Runtime
description: How events flow through the Runner and coordinate agent execution
---

import { Callout } from "fumadocs-ui/components/callout";
import { Cards, Card } from "fumadocs-ui/components/card";

During execution, agents communicate with the Runner and your application by yielding **events**. These events encapsulate messages, actions, and state changes that drive the agent's behavior. The Runner processes these events to manage the execution flow, update session state, and trigger side effects.

<Callout type="info" title="Learn More About Events">

For detailed information about event structure, content types, and EventActions, see the [Events documentation](/docs/framework/events).

</Callout>

## Events in Runtime Context

During execution, the Runner processes these key event properties to coordinate agent behavior and manage state:

| Property       | Runtime Significance                                      |
| -------------- | --------------------------------------------------------- |
| `invocationId` | Links events to the current execution cycle               |
| `author`       | Determines which agent should handle the event            |
| `content`      | Contains the actual message or action                     |
| `actions`      | Triggers side effects (state/artifact updates, transfers) |
| `partial`      | Controls whether the event is persisted                   |
| `branch`       | Tracks agent hierarchy for routing                        |

## Event Processing Flow

When an agent yields an event, the Runner follows this sequence to ensure proper state management and plugin integration:

<Mermaid
  chart="
graph TD
    A[Agent yields Event] --> B{Is partial?}
    B -->|Yes| C[Runner yields immediately to caller]
    C --> Z[Continue agent execution]
    B -->|No| D[Run plugin on_event callbacks]
    D --> E[Apply stateDelta via SessionService]
    E --> F[Record artifactDelta mappings]
    F --> G[SessionService.appendEvent]
    G --> H{MemoryService configured?}
    H -->|Yes| I[MemoryService.addSessionToMemory]
    H -->|No| J[Skip memory update]
    I --> K[Runner yields to caller]
    J --> K
    K --> L{isFinalResponse?}
    L -->|Yes| M[Run after_run callbacks]
    M --> N[End invocation]
    L -->|No| Z"
/>

The Runner first checks the `partial` flag. If `true`, it yields the event immediately without processing actions or persisting state. If `false`, it processes any `EventActions`, triggers plugin callbacks, updates session state via `SessionService`, and persists the event. Finally, it checks if the event is a final response to determine if the invocation should end.

### Key Runtime Behaviors

The Runner differentiates processing based on the `partial` flag:

**For Partial Events** (`partial: true`):

- Yielded immediately without processing actions
- Enables real-time UI updates (streaming chunks)
- No SessionService, MemoryService, or plugin callbacks
- Perfect for progress updates, thinking messages, or token-by-token responses

**For Complete Events** (`partial: false`):

- Actions are processed (stateDelta, artifactDelta, transfers)
- Plugin `on_event` callbacks are triggered
- SessionService persists the event with state changes
- MemoryService updates if configured
- Invocation may end if event is a final response

### Event Processing Example

```typescript
async *runAsync(context) {
  // Partial events - Runner yields immediately, does NOT persist
  yield new Event({
    author: "assistant",
    content: { parts: [{ text: "Thinking" }] },
    partial: true,
  });

  yield new Event({
    author: "assistant",
    content: { parts: [{ text: "Thinking..." }] },
    partial: true,
  });

  // Complete event - Runner processes actions, persists, then yields
  yield new Event({
    author: "assistant",
    content: { parts: [{ text: "Thinking... Done!" }] },
    partial: false, // Default - triggers full processing
    actions: new EventActions({
      stateDelta: { status: "completed" },
    }),
  });
}

// Runner processing for the complete event:
// 1. Checks if partial (false, so continue)
// 2. Runs plugin on_event callbacks
// 3. Applies stateDelta: { status: "completed" } to session.state
// 4. Calls SessionService.appendEvent() with state persisted
// 5. Calls MemoryService.addSessionToMemory() if configured
// 6. Yields event to your application
// 7. Checks isFinalResponse() - if true, ends invocation
```

This example demonstrates the full event lifecycle: streaming partial events for real-time updates, followed by a complete event that triggers state changes and persistence.

## Event Actions Processing

The Runner processes `EventActions` to apply side effects and control flow. These actions only take effect on complete events (not partial). This ensures that streaming updates don't trigger unintended state changes or agent transfers.

### State Delta: Persistent State Updates

When the Runner encounters `stateDelta`, it merges the changes into the session's state. Permanent keys persist across invocations, while temporary keys (prefixed with `temp_`) exist only for the current invocation.

```typescript
// Agent yields event with state change
yield new Event({
  author: "assistant",
  actions: new EventActions({
    stateDelta: {
      theme: "dark",
      lastUpdate: Date.now(),
      temp_calculationStep: "42", // Temporary, lost after invocation
    },
  }),
});

// Runner processing:
// 1. SessionService.appendEvent() is called
// 2. State delta applied: permanent keys persist, temp_* keys are ephemeral
// 3. null/undefined values delete keys from state
// 4. Updated session persisted to storage
```

### Artifact Delta: Versioned File Tracking

Artifact deltas track file/binary data versions associated with the session. This enables agents to reference versioned content across multiple invocations and supports workflows involving documents, images, or other binary data.

```typescript
// Agent saves artifact and includes version
const version = await artifactService.saveArtifact({
  appName,
  userId,
  sessionId,
  filename: "report.pdf",
  artifact: pdfData,
});

yield new Event({
  author: "assistant",
  actions: new EventActions({
    artifactDelta: { "report.pdf": version },
  }),
});

// Runner processing:
// 1. SessionService records filename â†’ version mapping
// 2. Mapping is persisted with session
// 3. Future invocations can retrieve artifacts by filename and version
```

### Agent Transfer: Dynamic Control Flow

Agents can transfer control to other agents by specifying `transferToAgent` in `EventActions`. The Runner locates the target agent and continues processing with it.

```typescript
yield new Event({
  author: "assistant",
  actions: new EventActions({
    transferToAgent: "specialist_agent",
  }),
});

// Runner processing:
// 1. Current agent's turn ends
// 2. Runner locates target agent via findAgent()
// 3. Next event processing continues with specialist_agent
```

## Error Handling via Events

Agents can signal errors by yielding events with `errorCode` and `errorMessage`. The Runner propagates these error events to your application, allowing for graceful handling.

```typescript
for await (const event of runner.runAsync({ userId, sessionId, newMessage })) {
  if (event.errorCode) {
    // Handle error from agent
    console.error(`Error ${event.errorCode}: ${event.errorMessage}`);
  } else {
    // Normal event processing
    console.log(event.content);
  }
}
```

## Runtime Configuration

The Runner's behavior can be customized via `runConfig` options passed during execution. For example, you can enable streaming mode to receive partial events in real-time.

```typescript
for await (const event of runner.runAsync({
  userId: "user_123",
  sessionId: "session_456",
  newMessage: { parts: [{ text: "Hello" }] },
  runConfig: {
    streamingMode: StreamingMode.SSE, // Controls partial event streaming
    // Other configuration options...
  },
})) {
  // Consume events
}
```

## Next Steps

<Cards>
  <Card
    title="ðŸ“¦ Events"
    description="Learn about event structure, content types, and EventActions"
    href="/docs/framework/events"
  />
  <Card
    title="ðŸŽ¯ Runner Orchestration"
    description="See how the Runner coordinates execution"
    href="/docs/framework/runtime/runner-orchestration"
  />
  <Card
    title="ðŸ”Œ Plugins"
    description="Intercept and modify events with plugins"
    href="/docs/framework/plugins"
  />
</Cards>
