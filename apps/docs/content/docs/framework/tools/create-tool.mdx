---
title: createTool
description: Create custom tools with explicit Zod schema validation
---

import { Cards, Card } from "fumadocs-ui/components/card";
import { Callout } from "fumadocs-ui/components/callout";

`createTool` is an alternative to [Function Tools](/docs/framework/tools/function-tools) that uses explicit Zod schemas for parameter validation instead of relying on TypeScript type inference. This approach gives you more control over parameter validation and error handling.

## When to Use createTool

Use `createTool` when you need:

- **Explicit validation rules**: Zod provides fine-grained control over what inputs are accepted
- **Clear error messages**: Zod validation errors are descriptive and help the LLM understand what went wrong
- **Complex parameter types**: Union types, discriminated unions, or nested objects beyond TypeScript inference
- **Custom transformations**: Apply transformations to inputs before they reach your function
- **Better TypeScript inference**: When the schema-based approach gives better IDE support

For simpler cases where TypeScript type inference is sufficient, consider using [Function Tools](/docs/framework/tools/function-tools) instead.

## Basic Usage

Here's a simple tool using `createTool`:

```typescript
import { createTool } from "@iqai/adk";
import { z } from "zod";
import { LlmAgent } from "@iqai/adk";

const addTool = createTool({
  name: "add",
  description: "Adds two numbers together",
  schema: z.object({
    a: z.number().describe("The first number"),
    b: z.number().describe("The second number"),
  }),
  fn: ({ a, b }) => {
    return { result: a + b };
  },
});

const agent = new LlmAgent({
  name: "calculator",
  instruction: "Help users with math calculations",
  tools: [addTool],
});
```

## Configuration

The `createTool` function accepts a configuration object with these properties:

| Property               | Type       | Required | Description                                                           |
| ---------------------- | ---------- | -------- | --------------------------------------------------------------------- |
| `name`                 | string     | Yes      | The tool name used by the LLM                                         |
| `description`          | string     | Yes      | What the tool does (sent to the LLM)                                  |
| `schema`               | Zod schema | No       | Validates and defines input parameters                                |
| `fn`                   | function   | Yes      | The function to execute                                               |
| `isLongRunning`        | boolean    | No       | Whether this tool performs long-running operations (default: `false`) |
| `shouldRetryOnFailure` | boolean    | No       | Whether to retry on failure (default: `false`)                        |
| `maxRetryAttempts`     | number     | No       | Maximum retry attempts (default: `3`)                                 |

## Defining Schemas

Zod schemas define what parameters your tool accepts. Here are common patterns:

### Required Parameters

```typescript
const searchTool = createTool({
  name: "search",
  description: "Search for information",
  schema: z.object({
    query: z.string().describe("The search query"),
    maxResults: z.number().describe("Maximum number of results"),
  }),
  fn: ({ query, maxResults }) => {
    return { found: 0, items: [] };
  },
});
```

### Optional Parameters

```typescript
const filterTool = createTool({
  name: "filterData",
  description: "Filter data with optional criteria",
  schema: z.object({
    data: z.array(z.string()).describe("Items to filter"),
    pattern: z.string().optional().describe("Optional filter pattern"),
    limit: z.number().default(10).describe("Result limit (defaults to 10)"),
  }),
  fn: ({ data, pattern, limit }) => {
    return { filtered: data };
  },
});
```

### Union Types and Discriminated Unions

```typescript
const operationTool = createTool({
  name: "operation",
  description: "Perform operations on data",
  schema: z.discriminatedUnion("type", [
    z.object({
      type: z.literal("sum"),
      numbers: z.array(z.number()),
    }),
    z.object({
      type: z.literal("concat"),
      strings: z.array(z.string()),
    }),
  ]),
  fn: ({ type, numbers, strings }) => {
    if (type === "sum") {
      return { result: numbers.reduce((a, b) => a + b, 0) };
    }
    return { result: strings.join("") };
  },
});
```

### Enum and Literal Types

```typescript
const formatTool = createTool({
  name: "formatData",
  description: "Format data in different ways",
  schema: z.object({
    data: z.string(),
    format: z.enum(["json", "csv", "xml"]).describe("Output format"),
    compress: z.boolean().default(false),
  }),
  fn: ({ data, format, compress }) => {
    return { formatted: data, format };
  },
});
```

## Advanced Features

### Long-Running Operations

Mark tools that take time to complete:

```typescript
const approvalTool = createTool({
  name: "requestApproval",
  description: "Request approval for an action",
  schema: z.object({
    action: z.string(),
    reason: z.string(),
  }),
  isLongRunning: true, // Mark as long-running
  fn: async ({ action, reason }, toolContext) => {
    // Generate request ID
    const requestId = `req-${Date.now()}`;

    return {
      status: "pending",
      requestId,
      message: "Approval request submitted",
    };
  },
});
```

### Retry Configuration

Configure automatic retries for tools that might fail temporarily:

```typescript
const apiCallTool = createTool({
  name: "fetchData",
  description: "Fetch data from an external API",
  schema: z.object({
    endpoint: z.string().url(),
  }),
  shouldRetryOnFailure: true,
  maxRetryAttempts: 5,
  fn: async ({ endpoint }) => {
    // This will retry up to 5 times on failure
    const response = await fetch(endpoint);
    return { success: response.ok };
  },
});
```

### Accessing ToolContext

Access session state and other context:

```typescript
const contextAwareTool = createTool({
  name: "getUserPreference",
  description: "Get user preferences from session state",
  schema: z.object({
    key: z.string(),
  }),
  fn: ({ key }, toolContext) => {
    const value = toolContext.state.get(`user:${key}`);
    return { key, value };
  },
});
```

## Schema Validation

Zod performs automatic validation of all inputs. If validation fails, the tool returns an error:

```typescript
const strictTool = createTool({
  name: "strictOperation",
  description: "An operation with strict validation",
  schema: z.object({
    email: z.string().email(),
    age: z.number().min(0).max(150),
    country: z.string().min(2).max(2), // ISO country code
  }),
  fn: ({ email, age, country }) => {
    return { valid: true, email, age, country };
  },
});

// If LLM provides invalid data:
// - Invalid email format â†’ returns error
// - Age outside 0-150 â†’ returns error
// - Country code not 2 chars â†’ returns error
```

The LLM sees these validation errors and can correct its input and retry.

## Error Handling

`createTool` validates inputs automatically, but you should also handle runtime errors:

```typescript
const robustTool = createTool({
  name: "robustOperation",
  description: "An operation with error handling",
  schema: z.object({
    id: z.string(),
  }),
  fn: async ({ id }) => {
    try {
      // Perform operation
      const result = await fetchItem(id);

      if (!result) {
        return {
          status: "not_found",
          message: `Item ${id} not found`,
        };
      }

      return {
        status: "success",
        data: result,
      };
    } catch (error) {
      return {
        status: "error",
        message: "An unexpected error occurred",
      };
    }
  },
});
```

## Comparison: createTool vs Function Tools

| Feature              | createTool                 | Function Tools            |
| -------------------- | -------------------------- | ------------------------- |
| Parameter Definition | Explicit Zod schema        | TypeScript type inference |
| Validation           | Strict, with custom rules  | Automatic from types      |
| Setup                | Requires schema definition | Minimal setup             |
| Control              | Fine-grained               | Simple & straightforward  |
| Best For             | Complex validation needs   | Quick tool creation       |

<Callout type="info" title="Choosing Between Approaches">
  - Use **createTool** when you need explicit validation and control - Use
  **Function Tools** when you want quick setup with minimal boilerplate - Both
  approaches work with agents - choose based on your needs
</Callout>

## Sharing Data Between Tools

Tools often need to pass data to each other. ADK-TS provides two main approaches:

1. **ToolContext State** - Store data in session state for other tools to access
2. **Return Values** - Return data that the LLM can pass to the next tool

### Using ToolContext to Share Data

All tools in a single agent turn share the same `ToolContext`, making it perfect for passing data between tools:

```typescript
import { createTool, ToolContext } from "@iqai/adk";
import { z } from "zod";

// Tool 1: Fetch customer data and store it
const getCustomer = createTool({
  name: "getCustomer",
  description: "Retrieves customer information by ID",
  schema: z.object({
    customerId: z.string().describe("The customer's ID"),
  }),
  fn: async ({ customerId }, toolContext: ToolContext) => {
    // Fetch customer data
    const customer = {
      id: customerId,
      name: "John Doe",
      tier: "premium",
      accountBalance: 1500,
    };

    // Store in session state for other tools
    toolContext.state.set("temp:customer", customer);

    return {
      status: "success",
      customer,
    };
  },
});

// Tool 2: Use the stored customer data
const applyDiscount = createTool({
  name: "applyDiscount",
  description: "Applies a discount based on customer tier",
  schema: z.object({
    amount: z.number().describe("The order amount"),
  }),
  fn: async ({ amount }, toolContext: ToolContext) => {
    // Retrieve customer data stored by previous tool
    const customer = toolContext.state.get("temp:customer");

    if (!customer) {
      return {
        status: "error",
        message:
          "Customer information not found. Please fetch customer data first.",
      };
    }

    // Calculate discount based on tier
    let discount = 0;
    if (customer.tier === "premium") {
      discount = amount * 0.15; // 15% for premium
    } else if (customer.tier === "gold") {
      discount = amount * 0.1; // 10% for gold
    }

    const finalAmount = amount - discount;

    return {
      status: "success",
      originalAmount: amount,
      discount,
      finalAmount,
      tier: customer.tier,
    };
  },
});

// Tool 3: Process payment using customer data
const processPayment = createTool({
  name: "processPayment",
  description: "Processes a payment for the customer",
  schema: z.object({
    amount: z.number().describe("Amount to charge"),
  }),
  fn: async ({ amount }, toolContext: ToolContext) => {
    const customer = toolContext.state.get("temp:customer");

    if (!customer) {
      return {
        status: "error",
        message: "Customer not found",
      };
    }

    // Check if customer has sufficient balance
    if (customer.accountBalance < amount) {
      return {
        status: "insufficient_funds",
        balance: customer.accountBalance,
        required: amount,
      };
    }

    return {
      status: "success",
      message: `Payment of $${amount} processed for ${customer.name}`,
      transactionId: `txn-${Date.now()}`,
    };
  },
});

const agent = new LlmAgent({
  name: "paymentAgent",
  tools: [getCustomer, applyDiscount, processPayment],
});
```

### Using temp: Prefix for Temporary Data

Use the `temp:` prefix in session state keys for data that's only needed during the current conversation turn. This data is automatically cleaned up:

```typescript
// Store temporary data
toolContext.state.set("temp:searchResults", results);
toolContext.state.set("temp:currentPage", 1);

// Retrieve temporary data
const results = toolContext.state.get("temp:searchResults");
```

### Returning Data for LLM to Pass

Alternatively, return structured data that the LLM can understand and pass to the next tool:

```typescript
const step1 = createTool({
  name: "step1",
  description: "First step that generates a user ID",
  schema: z.object({}),
  fn: () => {
    const userId = `user-${Date.now()}`;
    return {
      status: "success",
      userId, // LLM can extract this and pass it to step2
      message: `Created user with ID: ${userId}`,
    };
  },
});

const step2 = createTool({
  name: "step2",
  description: "Second step that uses the user ID from step1",
  schema: z.object({
    userId: z.string().describe("The user ID from the previous step"),
  }),
  fn: ({ userId }) => {
    return {
      status: "success",
      message: `Processed user ${userId}`,
    };
  },
});
```

The LLM will see the `userId` in step1's response and automatically pass it to step2.

## Related Topics

<Cards>
  <Card
    title="ðŸ“ Function Tools"
    description="Create tools from TypeScript functions with type inference"
    href="/docs/framework/tools/function-tools"
  />
  <Card
    title="âš¡ Built-in Tools"
    description="Ready-made tools for common tasks"
    href="/docs/framework/tools/built-in-tools"
  />
  <Card
    title="ðŸ”§ ToolContext"
    description="Learn about ToolContext capabilities and usage"
    href="/docs/framework/tools/tool-context"
  />
  <Card
    title="ðŸ¤– Agents"
    description="Learn how to configure agents with tools"
    href="/docs/framework/agents"
  />
  <Card
    title="ðŸ’¾ Sessions"
    description="Understand state management and persistence"
    href="/docs/framework/sessions"
  />
</Cards>
