---
title: Loop Agents
description: Repeat agent execution until conditions are met
---

import { Callout } from "fumadocs-ui/components/callout";
import { Cards, Card } from "fumadocs-ui/components/card";

Loop agents create powerful iterative workflows that keep improving until they reach the desired outcome. Think of it as your AI perfectionist - it won't stop until the work meets quality standards or maximum attempts are reached.

Perfect for scenarios where "good enough" isn't good enough. Whether you're refining content, debugging code, or iterating on creative work, loop agents ensure continuous improvement through repeated cycles of execution and evaluation.

Unlike [sequential agents](/docs/framework/agents/workflow-agents/sequential-agents) that run once, or [parallel agents](/docs/framework/agents/workflow-agents/parallel-agents) that run simultaneously, loop agents focus on iterative refinement and progressive enhancement.

<Callout type="info" title="Iterative Excellence">
  - **Key benefit:** Keep improving until you hit quality standards or resource
  limits.
  - **Perfect for:** Content refinement, problem solving, creative
  iteration, and quality convergence.
</Callout>

## Quick Start Example

Here's a research synthesis agent that iteratively gathers and refines information until a comprehensive understanding is achieved:

```typescript
import { LlmAgent, LoopAgent, Event, EventActions } from "@iqai/adk";

// Research question generator
const researchPlannerAgent = new LlmAgent({
  name: "research_planner_agent",
  model: "gemini-2.5-flash",
  description: "Generates focused research questions and search strategies",
  instruction:
    "Break down the research topic into specific, answerable questions. Prioritize the most important questions to investigate.",
  outputKey: "research_questions", // Key for storing generated questions
});

// Information gatherer using search
const infoGathererAgent = new LlmAgent({
  name: "info_gatherer_agent",
  model: "gemini-2.5-flash",
  description: "Gathers information from various sources",
  instruction:
    "Search for and collect relevant information to answer the research questions. Be thorough but focused.",
  outputKey: "gathered_info", // Key for storing gathered information
});

// Synthesis and gap analyzer
const synthesisAgent = new LlmAgent({
  name: "synthesis_agent",
  model: "gemini-2.5-flash",
  description: "Synthesizes information and identifies knowledge gaps",
  instruction:
    "Analyze the gathered information. Synthesize key findings and identify what important questions remain unanswered.",
  outputKey: "synthesis_analysis", // Key for storing synthesis results
});

// Research completion checker
const researchCompleterAgent = new (class extends LlmAgent {
  constructor() {
    super({
      name: "research_completer_agent",
      description: "Determines if research is sufficiently complete",
    });
  }

  protected async *runAsyncImpl(ctx: any) {
    const synthesis = ctx.session.state.get("synthesis_analysis", "");
    const questions = ctx.session.state.get("research_questions", "");

    // Check if major knowledge gaps remain
    const hasMajorGaps =
      synthesis.toLowerCase().includes("major gap") ||
      synthesis.toLowerCase().includes("insufficient") ||
      synthesis.toLowerCase().includes("unclear");

    // Emit event indicating whether to escalate (continue research) or not
    yield new Event({
      author: this.name,
      actions: new EventActions({ escalate: !hasMajorGaps }),
    });
  }
})();

// Research synthesis loop - iterative research refinement
const researchSynthesisAgent = new LoopAgent({
  name: "research_synthesis_agent",
  description:
    "Iteratively researches and synthesizes information until comprehensive understanding is achieved",
  subAgents: [
    researchPlannerAgent,
    infoGathererAgent,
    synthesisAgent,
    researchCompleterAgent,
  ],
  maxIterations: 4,
});
```

### Visual Flow

<Mermaid
  chart="
flowchart TD
    A[Start Research] --> L[LoopAgent]
    L --> RP[Research Planner Agent]
    RP --> IG[Information Gatherer Agent]
    IG --> S[Synthesis Agent]
    S --> RC[Research Completer Agent]
    RC -->|Not Complete| L
    RC -->|Complete| E[Final Synthesis Output]
"
/>

## How Loop Processing Works

Loop agents create iterative cycles where each iteration can build upon and improve previous results:

**ğŸ”„ Iteration Cycle**

1. **Execute sub-agents** - Run all agents in sequence (like sequential agents)
2. **Evaluate conditions** - Check if stopping criteria are met
3. **Continue or stop** - Either start next iteration or exit loop
4. **Progressive improvement** - Each cycle can reference and improve previous results

**ğŸšª Termination Strategies**

**Maximum Iterations** (Safety Net)

```typescript
maxIterations: 5; // Prevents infinite loops
```

**Quality-Based Stopping** (Smart Exit)

```typescript
// Agent evaluates quality and signals when done
yield new Event({
  actions: new EventActions({ escalate: qualityMet }),
});
```

**ğŸ“Š Progressive Enhancement**
Each iteration sees the full session history, allowing agents to:

- Reference previous attempts
- Learn from past iterations
- Build incrementally toward the goal
- Avoid repeating unsuccessful approaches

<Callout type="info" title="Loop Safety">
  Always set `maxIterations` as a safety net! Even with smart stopping
  conditions, having a maximum prevents runaway loops and unexpected resource
  consumption.
</Callout>

## Real-World Use Cases

**ğŸ“ Content Refinement Loop**  
Draft â†’ Improve â†’ Evaluate â†’ Repeat until quality standards met

**ğŸ” Research Deep-Dive**  
Initial Research â†’ Analyze Gaps â†’ Research More â†’ Repeat until comprehensive

**ğŸ› ï¸ Code Optimization**  
Generate Code â†’ Test Performance â†’ Optimize â†’ Repeat until benchmarks hit

**ğŸ¨ Creative Iteration**  
Generate Ideas â†’ Evaluate Creativity â†’ Refine â†’ Repeat until breakthrough

**ğŸ› Problem Debugging**  
Try Solution â†’ Test â†’ Debug Issues â†’ Repeat until tests pass

**ğŸ¯ Marketing Copy Testing**  
Write Copy â†’ A/B Test â†’ Analyze Results â†’ Improve â†’ Repeat

## When to Choose Loop Agents

<Callout type="success" title="Perfect For Iterative Improvement">
  - **Use when:** You need progressive refinement and have clear quality
  criteria
  - **Benefit:** Achieve higher quality results through iterative
  enhancement
</Callout>

### âœ… Choose Loop When:

- **Quality matters more than speed** - Need excellent results, not just "good enough"
- **Clear success criteria** - You can define "done" or "good enough"
- **Improvable processes** - Each iteration can meaningfully build on the last
- **Resource tolerance** - Can afford multiple processing cycles
- **Learning from attempts** - Previous tries inform better approaches

### âŒ Don't Use Loop When:

- Single execution produces sufficient results
- No clear improvement path exists between iterations
- Time/cost constraints prevent multiple cycles
- Risk of infinite loops without proper safeguards
- Tasks are already optimized and won't benefit from repetition

<Callout type="warn" title="Always Set Limits">
  - **Critical:** Always set `maxIterations` to prevent runaway loops.
  - **Monitor:** Watch resource usage during extended iterations.
  - **Test:** Validate your stopping conditions work reliably.
</Callout>

## Related Topics

<Cards>
  <Card
    title="ğŸ”„ Sequential Agents"
    description="Building blocks that loop agents execute in each iteration"
    href="/docs/framework/agents/workflow-agents/sequential-agents"
  />
  
  <Card
    title="âš¡ Parallel Agents"
    description="Alternative for concurrent processing without iteration"
    href="/docs/framework/agents/workflow-agents/parallel-agents"
  />

  <Card
    title="ğŸ—ï¸ Agent Builder"
    description="Fluent API for creating loop workflows with asLoop()"
    href="/docs/framework/agents/agent-builder"
  />
  
  <Card
    title="ğŸ¤– LLM Agents"
    description="Individual agents that power iterative loop workflows"
    href="/docs/framework/agents/llm-agents"
  />
</Cards>
