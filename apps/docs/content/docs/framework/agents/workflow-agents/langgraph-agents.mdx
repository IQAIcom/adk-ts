---
title: LangGraph Agents
description: Complex workflows with conditional branching and dynamic routing
---

import { Callout } from "fumadocs-ui/components/callout";
import { Cards, Card } from "fumadocs-ui/components/card";

LangGraph agents orchestrate sophisticated workflows with conditional branching, dynamic routing, and state-dependent decisions. Think of them as the master conductors for complex, multi-path processes where the next step depends on the results of previous steps.

Unlike simple workflow patterns ([sequential](/docs/framework/agents/workflow-agents/sequential-agents), [parallel](/docs/framework/agents/workflow-agents/parallel-agents), [loop](/docs/framework/agents/workflow-agents/loop-agents)), LangGraph agents handle complex decision trees, conditional flows, and dynamic routing based on content analysis, user preferences, or business rules.

<Callout type="info" title="Advanced Orchestration">
  - **Power:** Handle complex branching logic and conditional workflows
  - **Flexibility:** Dynamic routing based on content, context, or business rules
  - **Best for:** Sophisticated processes that require intelligent
  decision-making
</Callout>

## Quick Start Example

Here's a customer support system that intelligently routes inquiries based on analysis:

```typescript
import { LlmAgent, LangGraphAgent } from "@iqai/adk";
// Analyze incoming customer inquiry
const inquiryAnalyzerAgent = new LlmAgent({
  name: "inquiry_analyzer_agent",
  model: "gemini-2.5-flash",
  description:
    "Analyzes customer inquiries to determine category, urgency, and routing",
  instruction: `
    Analyze the customer inquiry and determine:
    - Category: technical, billing, refund, general, complaint
    - Urgency: low, medium, high, critical
    - Complexity: simple, moderate, complex
    - Sentiment: positive, neutral, negative, angry

    Output as JSON with these exact fields: category, urgency, complexity, sentiment.
  `,
  outputKey: "inquiry_analysis",
});

// Specialized support agents
const technicalSupportAgent = new LlmAgent({
  name: "technical_support_agent",
  model: "gemini-2.5-flash",
  description: "Handles technical issues with step-by-step troubleshooting",
  instruction: `
    Provide technical support for the customer's issue:
    - Diagnose the technical problem
    - Provide step-by-step troubleshooting guidance
    - Offer workarounds or solutions
    - Escalate to engineering if needed

    Be patient, clear, and technically accurate.
  `,
  outputKey: "technical_response",
});

const billingSupportAgent = new LlmAgent({
  name: "billing_support_agent",
  model: "gemini-2.5-flash",
  description: "Handles billing inquiries and payment issues",
  instruction: `
    Handle billing and payment-related inquiries:
    - Review account charges and billing history
    - Explain billing policies and charges
    - Process refunds or adjustments when appropriate
    - Escalate complex billing disputes

    Be transparent about charges and helpful with resolutions.
  `,
  outputKey: "billing_response",
});

const escalationHandlerAgent = new LlmAgent({
  name: "escalation_handler_agent",
  model: "gemini-2.5-flash",
  description: "Handles escalated cases requiring human intervention",
  instruction: `
    Handle escalated customer cases with empathy and urgency:
    - Acknowledge the customer's frustration
    - Provide immediate relief or compensation if appropriate
    - Escalate to appropriate internal teams
    - Provide clear next steps and timelines
    - Follow up personally on resolution

    Show genuine concern and commitment to resolution.
  `,
  outputKey: "escalation_response",
});

const generalSupportAgent = new LlmAgent({
  name: "general_support_agent",
  model: "gemini-2.5-flash",
  description: "Handles general inquiries and provides information",
  instruction: `
    Provide helpful information and support for general inquiries:
    - Answer questions about products/services
    - Provide account information and guidance
    - Direct to appropriate resources
    - Offer proactive assistance

    Be friendly, informative, and proactive.
  `,
  outputKey: "general_response",
});

/**
 * Customer Support Workflow
 *
 * Implements the following routing logic:
 * 1. Analyze Inquiry -> Decision
 * 2. Decision Branches:
 *    - Critical/Angry -> Escalation Handler
 *    - Technical -> Technical Support -> End
 *    - Billing/Refund -> Billing Support -> Resolved?
 *      - No -> Escalation Handler -> End
 *      - Yes -> End
 *    - General -> General Support -> End
 */
const supportWorkflowAgent = new LangGraphAgent({
  name: "support_workflow_agent",
  description:
    "Intelligent customer support routing and handling system using LangGraph for agent orchestration.",
  rootNode: "analyze",
  maxSteps: 10,
  nodes: [
    {
      name: "analyze",
      agent: inquiryAnalyzerAgent,
      targets: ["escalate", "technical", "billing", "general"],
    },
    {
      name: "technical",
      agent: technicalSupportAgent,
      condition: (event: any) => {
        try {
          // Parse JSON analysis from the previous event
          const analysis = JSON.parse(
            event.content.match(/\{[\s\S]*\}/)?.[0] || "{}"
          );
          // Route to technical support if category matches and not critical/angry
          return (
            analysis.category === "technical" &&
            analysis.urgency !== "critical" &&
            analysis.sentiment !== "angry"
          );
        } catch {
          return false;
        }
      },
    },
    {
      name: "billing",
      agent: billingSupportAgent,
      targets: ["escalate"], // Can escalate if unresolved
      condition: (event: any) => {
        try {
          // Parse JSON analysis from the previous event
          const analysis = JSON.parse(
            event.content.match(/\{[\s\S]*\}/)?.[0] || "{}"
          );
          // Route to billing support if category matches and not critical/angry
          return (
            ["billing", "refund"].includes(analysis.category) &&
            analysis.urgency !== "critical" &&
            analysis.sentiment !== "angry"
          );
        } catch {
          return false;
        }
      },
    },
    {
      name: "escalate",
      agent: escalationHandlerAgent,
      condition: (event: any) => {
        try {
          // Parse JSON analysis from the previous event
          const analysis = JSON.parse(
            event.content.match(/\{[\s\S]*\}/)?.[0] || "{}"
          );

          // Escalate if critical, angry, or complaint
          if (
            analysis.urgency === "critical" ||
            analysis.sentiment === "angry" ||
            analysis.category === "complaint"
          ) {
            return true;
          }

          // Also escalate if billing agent mentions escalation
          return event.content.toLowerCase().includes("escalate");
        } catch {
          return false;
        }
      },
    },
    {
      name: "general",
      agent: generalSupportAgent,
      condition: (event: any) => {
        try {
          // Parse JSON analysis from the previous event
          const analysis = JSON.parse(
            event.content.match(/\{[\s\S]*\}/)?.[0] || "{}"
          );
          // Route to general support if category matches and not critical/angry
          return (
            analysis.category === "general" &&
            analysis.urgency !== "critical" &&
            analysis.sentiment !== "angry"
          );
        } catch {
          return false;
        }
      },
    },
  ],
});

// Export the main workflow agent for use in other modules
export { supportWorkflowAgent };
```

### Visual Flow

<Mermaid
  chart="
graph TD
    Start[Customer Inquiry] --> A[Analyze Inquiry]
    A[Analyze Inquiry] -->|Critical/Angry| B[Escalation Handler]
    A -->|Technical| C[Technical Support]
    A -->|Billing/Refund| D[Billing Support]
    D -->|Not Resolved| B
    D -->|Resolved| E[End]
    A -->|General| F[General Support]
    B --> E
    C --> E
    F --> E
    E[End]
"
/>

## How LangGraph Processing Works

LangGraph agents enable sophisticated workflow orchestration through conditional routing and state-dependent decisions:

**ğŸŒ Node-Based Architecture**

- **Nodes:** Individual processing steps (typically agents)
- **Edges:** Conditional transitions between nodes
- **State:** Shared context that influences routing decisions
- **Dynamic routing:** Next step determined by current state and results

**ğŸ§  Intelligent Decision Making**

1. **Execute current node** - Run the agent at current workflow position
2. **Evaluate state** - Analyze results and current context
3. **Determine next step** - Use conditional logic to choose next node
4. **Route dynamically** - Move to appropriate next node or terminate

**ğŸ”€ Conditional Flows**

```typescript
next: (ctx) => {
  const analysis = ctx.session.state.get("analysis");

  if (analysis.urgency === "critical") return "escalate";
  if (analysis.category === "technical") return "tech-support";
  return "general-support";
};
```

**ğŸ“Š State Management**

- All nodes share the same session state
- Previous results influence future routing decisions
- Context accumulates throughout the workflow
- Decisions can reference any previous step's output

<Callout type="info" title="Graph Design Patterns">
  - **Start simple:** Begin with basic routing logic, add complexity gradually
  - **Plan thoroughly:** Map out all possible paths before implementation
  - **Handle edge cases:** Always have fallback routes for unexpected conditions
</Callout>

## Advanced Patterns

### Multi-Stage Decision Trees

```typescript
const nodes = [
  {
    id: "initial-triage",
    agent: triageAgent,
    next: (ctx) => {
      const triage = ctx.session.state.get("triage");
      return triage.requiresHuman ? "human-review" : "automated-processing";
    },
  },
  {
    id: "automated-processing",
    agent: automatedProcessor,
    next: (ctx) => {
      const result = ctx.session.state.get("automated_result");
      return result.confidence > 0.9 ? "finalize" : "human-review";
    },
  },
  {
    id: "human-review",
    agent: humanReviewAgent,
    next: () => "finalize",
  },
  {
    id: "finalize",
    agent: finalizationAgent,
    next: () => "end",
  },
];
```

### Loop Within Graph

```typescript
{
  id: "quality-check",
  agent: qualityAssessor,
  next: (ctx) => {
    const quality = ctx.session.state.get("quality_score");
    const attempts = ctx.session.state.get("improvement_attempts", 0);

    if (quality >= 8) return "approve";
    if (attempts >= 3) return "escalate";
    return "improve"; // Loop back for another improvement cycle
  }
}
```

### Parallel Processing Integration

```typescript
{
  id: "parallel-analysis",
  agent: parallelAnalysisAgent, // This could be a ParallelAgent
  next: (ctx) => {
    const results = ctx.session.state.get("parallel_results");
    const consensus = analyzeConsensus(results);
    return consensus.agreement > 0.8 ? "proceed" : "additional-review";
  }
}
```

## Real-World Use Cases

**ğŸ¥ Medical Diagnosis Workflow**  
Symptoms â†’ Initial Assessment â†’ Specialist Routing â†’ Tests â†’ Diagnosis â†’ Treatment Plan

**âš–ï¸ Legal Document Review**  
Document Analysis â†’ Risk Assessment â†’ Complexity Routing â†’ Specialist Review â†’ Approval Flow

**ğŸ’¼ Loan Application Processing**  
Application Review â†’ Risk Assessment â†’ Manual/Auto Route â†’ Verification â†’ Decision â†’ Notification

**ğŸ“± App Feature Requests**  
Request Analysis â†’ Category Assignment â†’ Feasibility Check â†’ Priority Routing â†’ Development Queue

**ğŸ¯ Content Moderation**  
Content Analysis â†’ Risk Scoring â†’ Auto-Approve/Review Route â†’ Human Review â†’ Action Decision

**ğŸ” Fraud Detection**  
Transaction Analysis â†’ Risk Scoring â†’ Investigation Routing â†’ Evidence Gathering â†’ Resolution

## When to Choose LangGraph Agents

<Callout type="success" title="Perfect for Complex Decision Trees">
  - **Use when:** You need sophisticated branching logic and conditional
  workflows
  - **Benefit:** Handle complex processes that simple linear or
  parallel patterns can't address
</Callout>

### âœ… Choose LangGraph When:

- **Complex routing logic** - Next step depends on content analysis or business rules
- **Multi-path workflows** - Different paths through the process based on conditions
- **State-dependent decisions** - Routing changes based on accumulated context
- **Exception handling** - Need sophisticated error handling and escalation paths
- **Adaptive processes** - Workflow adapts based on intermediate results
- **Integration of patterns** - Combining sequential, parallel, and loop behaviors

### âŒ Don't Use LangGraph When:

- Simple linear workflows are sufficient (use Sequential)
- All tasks can run independently (use Parallel)
- Simple iteration is needed (use Loop)
- Workflow complexity outweighs the benefits
- Debugging and maintenance overhead is too high

## Design Best Practices

### 1. Start with Flow Mapping

```
Before coding, map out:
- All possible entry points
- Decision criteria at each branch
- All possible exit conditions
- Error handling and fallback paths
```

### 2. Keep Nodes Focused

```typescript
// âœ… Good: Single responsibility
const riskAssessor = new LlmAgent({
  instruction: "Assess financial risk only",
});

// âŒ Avoid: Multiple responsibilities
const everythingAgent = new LlmAgent({
  instruction: "Assess risk, make decisions, and format output",
});
```

### 3. Handle Edge Cases

```typescript
next: (ctx) => {
  const analysis = ctx.session.state.get("analysis");

  // Always handle missing or malformed data
  if (!analysis) return "error-handler";

  // Provide fallback for unexpected values
  switch (analysis.category) {
    case "technical":
      return "tech-support";
    case "billing":
      return "billing-support";
    default:
      return "general-support"; // Fallback
  }
};
```

### 4. Test All Paths

```
Ensure every possible route through your graph:
- Has been tested with real data
- Handles expected and edge case scenarios
- Has appropriate error handling
- Can reach a terminal state
```

<Callout type="warn" title="Graph Complexity Warning">
  - **Start simple:** Complex graphs are hard to debug and maintain
  - **Document thoroughly:** Clear documentation is crucial for complex flows
  - **Test extensively:** Every path and edge case should be tested
</Callout>

## Related Topics

<Cards>
  <Card
    title="ğŸ”„ Sequential Agents"
    description="Building blocks that can be nodes within LangGraph workflows"
    href="/docs/framework/agents/workflow-agents/sequential-agents"
  />
  <Card
    title="âš¡ Parallel Agents"
    description="Can be integrated as nodes for concurrent processing steps"
    href="/docs/framework/agents/workflow-agents/parallel-agents"
  />
  <Card
    title="ğŸ” Loop Agents"
    description="Can be used as nodes for iterative processing within graphs"
    href="/docs/framework/agents/workflow-agents/loop-agents"
  />
  
  <Card
    title="ğŸ—ï¸ Agent Builder"
    description="Fluent API for creating LangGraph workflows with asLangGraph()"
    href="/docs/framework/agents/agent-builder"
  />

  <Card
    title="ğŸ¤– LLM Agents"
    description="Individual agents that serve as nodes in LangGraph workflows"
    href="/docs/framework/agents/llm-agents"
  />
</Cards>
