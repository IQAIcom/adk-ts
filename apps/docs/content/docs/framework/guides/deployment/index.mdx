---
title: Deployment
description: Learn how to deploy ADK-TS agents to various platforms and environments
---

import { Cards, Card } from "fumadocs-ui/components/card";
import { Callout } from "fumadocs-ui/components/callout";

Deploy your ADK-TS agents to production using various platforms and deployment strategies. This guide covers core deployment concepts and platform-specific implementations.

## Quick Start Decision Tree

Choose your deployment path based on your needs:

<Cards>
  <Card
    title="üöÄ Quick & Managed"
    description="Railway - easiest deployment, auto-detect or use Docker (5-15 min)"
    href="/docs/guides/deployment/railway"
  />
  <Card
    title="‚ö° Serverless API"
    description="Vercel - serverless functions for API agents and webhooks (5-10 min)"
    href="/docs/guides/deployment/vercel"
  />
  <Card
    title="‚òÅÔ∏è Enterprise Cloud"
    description="AWS - Lambda, ECS Fargate, or EC2 for scalable cloud deployment (15-60 min)"
    href="/docs/guides/deployment/aws"
  />
  <Card
    title="üîß Self-Hosted & Flexible"
    description="Docker - full control, deploy anywhere you want (30+ min)"
    href="/docs/guides/deployment/docker"
  />
</Cards>

## Docker Fundamentals

Railway can auto-deploy without Docker knowledge (using Nixpacks), but understanding Docker basics helps if you need custom configurations. Docker is required for self-hosted deployments.

### Platform Architecture

Your local machine might use a different processor architecture than cloud servers:

- **ARM64**: Apple Silicon Macs (M1/M2/M3/M4) and some modern servers
- **AMD64**: Most cloud providers (Railway, AWS, Google Cloud, Azure)

When deploying to cloud platforms, build specifically for AMD64:

```bash
docker buildx build --platform linux/amd64 -t my-agent:latest .
```

<Callout type="info" title="Why This Matters">
  If you build on Apple Silicon without specifying `--platform linux/amd64`,
  your image won't run on most cloud servers. Always specify the platform for
  production builds.
</Callout>

### Container Registries

After building your image, push it to a registry so cloud platforms can access it:

**DockerHub** (Easiest for beginners)

- Free tier available
- Public and private repositories
- `docker.io/username/image:tag`

**GitHub Container Registry** (If you use GitHub)

- Integrated with GitHub repos
- Fine-grained access control
- `ghcr.io/username/image:tag`

**AWS ECR** (If you use AWS)

- Integrated with AWS services
- Regional deployment
- `aws_account_id.dkr.ecr.region.amazonaws.com/image:tag`

## Dockerfile Reference

Use this standard Dockerfile for ADK-TS agents. Both Railway and Docker deployments use this same configuration.

### Basic Dockerfile

Create a `Dockerfile` in your project root:

```dockerfile
# Use Node.js 20 Alpine as the base image (lightweight Linux distribution)
FROM node:20-alpine

# Enable pnpm package manager and set a specific version for consistency
RUN corepack enable && corepack prepare pnpm@9.12.0 --activate

# Set the working directory inside the container
WORKDIR /app

# Copy package files first for better Docker layer caching
COPY package.json pnpm-lock.yaml ./

# Install dependencies using frozen lockfile for reproducible builds
RUN pnpm install --frozen-lockfile

# Copy TypeScript config and source code
COPY tsconfig.json ./
COPY src ./src

# Build the project
RUN pnpm build

# Set production environment
ENV NODE_ENV=production

# Define the command to run when the container starts
CMD ["node", "dist/index.js"]
```

### Multi-Stage Dockerfile (Advanced)

For production deployments, use multi-stage builds to create smaller, more secure images:

```dockerfile
# Build stage - compiles TypeScript
FROM node:20-alpine AS builder

RUN corepack enable && corepack prepare pnpm@9.12.0 --activate
WORKDIR /app

COPY package.json pnpm-lock.yaml ./
RUN pnpm install --frozen-lockfile

COPY tsconfig.json ./
COPY src ./src
RUN pnpm build

# Production stage - runs the compiled code
FROM node:20-alpine

RUN corepack enable && corepack prepare pnpm@9.12.0 --activate
WORKDIR /app

# Only install production dependencies
COPY package.json pnpm-lock.yaml ./
RUN pnpm install --frozen-lockfile --prod

# Copy compiled code from build stage
COPY --from=builder /app/dist ./dist

ENV NODE_ENV=production
CMD ["node", "dist/index.js"]
```

**Benefits**: Smaller images (no dev dependencies), faster deployments, improved security.

### .dockerignore

Create a `.dockerignore` file to exclude unnecessary files from your Docker build:

```
node_modules
dist
.git
.env
.env.*
*.log
.DS_Store
coverage
.vscode
.idea
README.md
.gitignore
```

This reduces image size and prevents accidentally including sensitive data.

## Coming Soon

We're working on guides for additional platforms:

- **‚òÅÔ∏è Google Cloud** - Cloud Run and GKE deployment
- **‚öì Kubernetes** - Container orchestration for scalable deployments
- **üî∑ Azure** - Azure Functions and Container Instances

<Callout type="info" title="Contributions Welcome">
  Have experience deploying ADK-TS agents to other platforms? We welcome
  contributions! Share your deployment guides by opening a pull request on
  [GitHub](https://github.com/IQAIcom/adk-ts/pulls) or start a discussion in our
  [community forum](https://github.com/IQAIcom/adk-ts/discussions).
</Callout>

## Environment Variables

Environment variables configure your ADK-TS agent's runtime behavior without hardcoding values in your code. They store API keys, model settings, and other configuration that varies between environments.

### Common ADK-TS Environment Variables

Most ADK-TS agents need these environment variables:

**LLM Provider API Keys:**

```bash
# For OpenAI models (GPT-4, GPT-3.5)
OPENAI_API_KEY=sk-...

# For Google AI models (Gemini)
GOOGLE_API_KEY=...

# For Anthropic models (Claude)
ANTHROPIC_API_KEY=sk-ant-...
```

**Model Configuration:**

```bash
# Specify which model to use
LLM_MODEL=gpt-4
# or
LLM_MODEL=gemini-2.5-flash
# or
LLM_MODEL=claude-sonnet-4

# Optional: Temperature, max tokens, etc.
LLM_TEMPERATURE=0.7
LLM_MAX_TOKENS=2000
```

**Agent-Specific Variables:**

```bash
# For Discord bots
DISCORD_TOKEN=...
DISCORD_CLIENT_ID=...

# For Telegram bots
TELEGRAM_BOT_TOKEN=...

# For Slack bots
SLACK_BOT_TOKEN=...
SLACK_SIGNING_SECRET=...

# Database connections
DATABASE_URL=postgresql://user:password@host:5432/dbname

# Memory/RAG services
PINECONE_API_KEY=...
PINECONE_ENVIRONMENT=...
```

**Application Settings:**

```bash
# Environment type
NODE_ENV=production

# Debug mode
ADK_DEBUG=false

# Logging level
LOG_LEVEL=info
```

### Example .env File

For local development, create a `.env` file in your project root:

```bash
# .env - Local development configuration
# NEVER commit this file to version control!

# LLM Configuration
OPENAI_API_KEY=sk-proj-...
GOOGLE_API_KEY=AIzaSy...
LLM_MODEL=gemini-2.5-flash

# Bot Tokens
DISCORD_TOKEN=MTIzNDU2Nzg5...

# Application Settings
NODE_ENV=development
ADK_DEBUG=true
LOG_LEVEL=debug
```

### Security Best Practices

<Callout type="warn" title="Never Commit Secrets">
  Always add `.env` to your `.gitignore` to prevent committing sensitive data.
  Never share environment files publicly or include them in Docker images.
</Callout>

**Follow these rules:**

1. **Never hardcode secrets** in your source code
2. **Use .env files locally** for development (add to `.gitignore`)
3. **Use platform secret management** in production:
   - Railway: Variables tab in dashboard
   - Vercel: Environment Variables in project settings
   - AWS: Systems Manager Parameter Store or Secrets Manager
   - Docker: `--env-file`, `-e` flags, or secrets management
4. **Rotate API keys regularly** and use scoped permissions where possible
5. **Document required variables** in your README for team members
6. **Use different values** for development, staging, and production
7. **Validate required variables** at startup to catch configuration errors early

### Platform-Specific Setup

Each deployment platform handles environment variables differently:

- **Railway**: Set in the Variables tab of your project dashboard ([Railway guide](/docs/guides/deployment/railway))
- **Vercel**: Set in Settings ‚Üí Environment Variables ([Vercel guide](/docs/guides/deployment/vercel))
- **AWS**: Use AWS Systems Manager Parameter Store, Secrets Manager, or Lambda environment variables ([AWS guide](/docs/guides/deployment/aws))
- **Docker**: Pass via `-e` flags, `.env` files, or `docker-compose.yml` ([Docker guide](/docs/guides/deployment/docker))

See the platform-specific guides for detailed instructions on how to configure environment variables for your chosen deployment method.

## Prerequisites

Before deploying your agent, ensure you have:

- **Built and tested** your ADK-TS agent locally
- **Environment variables** documented and ready to configure
- **Dependencies** properly defined in `package.json`
- **Production configuration** prepared (API keys, database connections, etc.)

## Common Troubleshooting

These issues are common across all deployment platforms. For platform-specific troubleshooting, see the respective deployment guides.

### Build Failures

**Problem**: Deployment fails during the build step

**Common Causes:**

- Missing dependencies in `package.json`
- TypeScript compilation errors
- Incompatible Node.js version
- Build scripts not configured correctly

**Solutions:**

- Test the build locally first: `pnpm build`
- Ensure `package.json` includes all required dependencies
- Verify Node.js version compatibility (ADK-TS requires Node.js ‚â•22)
- Check that `tsconfig.json` is properly configured
- Review build logs for specific error messages

### Platform Architecture Mismatches

**Problem**: "exec format error" or container won't start

**Cause**: Image built for wrong CPU architecture (e.g., ARM64 image on AMD64 server)

**Solutions:**

- Always specify platform when building for cloud deployment:
  ```bash
  docker buildx build --platform linux/amd64 -t my-agent:latest .
  ```
- See [Platform Architecture](/docs/guides/deployment#platform-architecture) for details

### Environment Variables Not Working

**Problem**: Agent can't access API keys or configuration

**Common Causes:**

- Variables not set in deployment platform
- Typos in variable names (case-sensitive)
- Variables not available in correct environment (dev/staging/prod)
- `.env` file committed to git (security risk)

**Solutions:**

- Verify variables are set in platform dashboard
- Check variable names match exactly (e.g., `OPENAI_API_KEY` not `OPENAI_KEY`)
- Redeploy after adding new variables
- Never commit `.env` files - add to `.gitignore`
- Use platform-specific secret management in production

### Container Startup Failures

**Problem**: Container starts but immediately exits

**Common Causes:**

- Missing `CMD` or incorrect entry point in Dockerfile
- Application crashes on startup
- Required environment variables missing
- Port conflicts

**Solutions:**

- Check container logs for error messages
- Ensure Dockerfile has proper `CMD` directive:
  ```dockerfile
  CMD ["node", "dist/index.js"]
  ```
- Verify all required environment variables are set
- Test locally with Docker first:
  ```bash
  docker run --env-file .env my-agent:latest
  ```

### Dependency Installation Failures

**Problem**: `pnpm install` or `npm install` fails during deployment

**Common Causes:**

- Lockfile not committed to repository
- Network issues accessing npm registry
- Private packages without authentication
- Disk space issues

**Solutions:**

- Always commit `pnpm-lock.yaml` or `package-lock.json`
- Use `--frozen-lockfile` flag for reproducible builds
- Configure registry authentication for private packages
- Check platform disk space limits

### Memory/Resource Exhaustion

**Problem**: Agent crashes or gets killed unexpectedly

**Common Causes:**

- Insufficient memory allocation
- Memory leaks in agent code
- Large file processing
- Too many concurrent requests

**Solutions:**

- Increase memory limits in platform configuration
- Monitor memory usage and optimize agent code
- Implement streaming for large data processing
- Add rate limiting for API endpoints
- Use pagination for large datasets

### Network/Connection Issues

**Problem**: Agent can't connect to external services (APIs, databases)

**Common Causes:**

- Firewall/security group blocking connections
- Incorrect API endpoints or URLs
- SSL/TLS certificate issues
- Timeout configurations too strict

**Solutions:**

- Verify firewall rules allow outbound connections
- Check API endpoints are correct and accessible
- Ensure SSL certificates are valid
- Increase timeout settings if needed
- Test connectivity from deployment environment

## General Best Practices

- **Environment Variables**: Never commit sensitive data; use platform-specific secret management
- **Health Checks**: Implement health check endpoints for monitoring
- **Logging**: Configure proper logging for production debugging
- **Error Handling**: Ensure graceful error handling and recovery
- **Resource Limits**: Set appropriate memory and CPU limits
- **Monitoring**: Set up monitoring and alerting for your deployed agents

## Next Steps

Choose a deployment platform from the guides above to get started, or explore our other guides for best practices and troubleshooting tips.
