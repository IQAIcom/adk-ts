---
title: Multi-Agent Systems
description: Compose specialized agents for complex distributed tasks
---

import { Cards, Card } from "fumadocs-ui/components/card";
import { Callout } from "fumadocs-ui/components/callout";

Multi-Agent Systems let you build sophisticated applications by composing specialized agents rather than creating monolithic solutions. Think of it as building a team where each agent has expertise in a specific domain - research, analysis, writing, validation - and they coordinate to solve complex problems that no single agent could handle effectively.

Unlike single agents that try to do everything, multi-agent systems promote modularity, reusability, and maintainability. Each agent focuses on what it does best, and you compose them with agents that use [large language models](/docs/framework/agents/llm-agents), [workflow patterns](/docs/framework/agents/workflow-agents) or [custom orchestration](/docs/framework/agents/custom-agents) to create powerful distributed systems.

<Callout type="info" title="Team Approach">
  **When to use multi-agent systems:** Complex tasks requiring multiple
  specializations, workflows needing clear separation of concerns, or
  applications where different components need independent scaling and
  maintenance.
</Callout>

## Quick Start Example

Here's a research and writing system that coordinates multiple specialists:

```typescript
import { LlmAgent, SequentialAgent, ParallelAgent, AgentTool } from "@iqai/adk";

// Specialist agents for data gathering
const webSearcher = new LlmAgent({
  name: "web-searcher",
  model: "gemini-2.5-flash",
  description: "Searches web for current information",
  instruction: "Search for recent, authoritative information about the topic",
  outputKey: "web_results",
});

const academicSearcher = new LlmAgent({
  name: "academic-searcher",
  model: "gemini-2.5-flash",
  description: "Finds academic papers and studies",
  instruction: "Find relevant academic papers and research studies",
  outputKey: "academic_results",
});

// Parallel research phase
const researchPhase = new ParallelAgent({
  name: "research-phase",
  description: "Gather information from multiple sources",
  subAgents: [webSearcher, academicSearcher],
});

// Analysis and writing specialists
const analyzer = new LlmAgent({
  name: "analyzer",
  model: "gemini-2.5-flash",
  description: "Analyzes and synthesizes research data",
  instruction:
    "Analyze {web_results} and {academic_results} to identify key insights and patterns",
  outputKey: "analysis",
});

const writer = new LlmAgent({
  name: "writer",
  model: "gemini-2.5-flash",
  description: "Creates comprehensive reports",
  instruction:
    "Write a detailed report based on {analysis}, include citations and conclusions",
  outputKey: "draft_report",
});

const reviewer = new LlmAgent({
  name: "reviewer",
  model: "gemini-2.5-flash",
  description: "Reviews content for accuracy and clarity",
  instruction:
    "Review {draft_report} for accuracy, clarity, and completeness. Suggest improvements",
  outputKey: "review_feedback",
});

// Complete workflow
const researchAndWritingSystem = new SequentialAgent({
  name: "research-writing-system",
  description: "Complete research and writing workflow",
  subAgents: [
    researchPhase, // Parallel research
    analyzer, // Sequential analysis
    writer, // Sequential writing
    reviewer, // Sequential review
  ],
});

// Usage
const result = await researchAndWritingSystem.run({
  message:
    "Research and write a comprehensive report on renewable energy trends in 2024",
});
```

### What Makes This Multi-Agent

This system demonstrates key multi-agent capabilities:

- **ðŸ”„ Parallel Processing**: Web and academic research happen simultaneously
- **ðŸ‘¥ Specialization**: Each agent has a focused responsibility and expertise
- **ðŸ“Š Data Flow**: Results flow through the system via session state
- **ðŸŽ¯ Coordination**: Sequential and parallel patterns orchestrate the team
- **ðŸ”§ Modularity**: Each agent can be tested, updated, or replaced independently

## ADK Primitives for Multi-Agent Composition

ADK-TS provides three core primitives that enable sophisticated multi-agent system design:

### Agent Hierarchy

Build parent-child relationships by assigning `subAgents` to create delegation trees and execution scopes.

**Key Rules:**

- Single Parent: Each agent can only have one parent (enforced at runtime)
- Tree Navigation: Use `parentAgent` property or `findAgent(name)` for traversal
- Scope Definition: Hierarchy defines transfer boundaries and workflow orchestration scope

```typescript
const specialist = new LlmAgent({ name: "billing-specialist" });
const coordinator = new LlmAgent({
  name: "coordinator",
  subAgents: [specialist], // Creates parent-child relationship
});

// Framework automatically sets: specialist.parentAgent === coordinator
// Navigate hierarchy: coordinator.findAgent("billing-specialist")
```

### Workflow Orchestrators

Pre-built agents that manage execution flow without performing tasks themselves:

**SequentialAgent**: Executes sub-agents in order, passing shared context

- Context flows sequentially, enabling state-based pipelines
- Errors stop execution unless handled explicitly

**ParallelAgent**: Executes sub-agents concurrently

- Creates separate execution branches (`ParentBranch.ChildName`)
- Shared session state with distinct context paths
- Events arrive interleaved from concurrent executions

**LoopAgent**: Repeats sub-agents until termination conditions

- Stops on `maxIterations` or when any sub-agent returns `escalate: true`
- Persistent context across iterations enables iterative refinement

```typescript
// Sequential execution with state flow
const pipeline = new SequentialAgent({
  name: "data-pipeline",
  subAgents: [validator, processor, reporter],
});

// Parallel execution with branching
const gatherer = new ParallelAgent({
  name: "info-gatherer",
  subAgents: [webFetcher, apiFetcher], // Run concurrently
});

// Loop with termination condition
const refinementLoop = new LoopAgent({
  name: "quality-loop",
  maxIterations: 5,
  subAgents: [improver, qualityChecker, stopCondition],
});
```

### Communication Mechanisms

#### Shared Session State with outputKey

Save outputs to session state for downstream agents.

- Set `outputKey` on a producer; reference `{key}` in consumer instructions
- Prefer flat, consistent key names (e.g., `result`, `summary`, `status`)
- Validate presence and format before consuming; consider schemas on the producer

```ts
import { LlmAgent, SequentialAgent } from "@iqai/adk";

const agentA = new LlmAgent({
  name: "agent_a",
  description: "Finds capital",
  instruction: "Find the capital of France.",
  outputKey: "capital_city",
});

const agentB = new LlmAgent({
  name: "agent_b",
  description: "Describes city",
  instruction: "Tell me about {capital_city}.",
});

const cityInfo = new SequentialAgent({
  name: "city_info",
  description: "City info pipeline",
  subAgents: [agentA, agentB],
});
```

#### LLM-Driven Delegation (Transfer)

Let an `LlmAgent` decide when to hand off to a more suitable sub-agent.

- Works automatically with `AutoFlow` when sub-agents exist and transfers arenâ€™t disallowed
- Write coordinator instructions that clearly map intents to target agent names
- Minimize ambiguity by giving sub-agents precise, non-overlapping `description`s

```ts
import { LlmAgent } from "@iqai/adk";

const billing = new LlmAgent({
  name: "billing",
  description: "Handles billing issues",
});
const support = new LlmAgent({
  name: "support",
  description: "Handles technical issues",
});

const router = new LlmAgent({
  name: "helpdesk_coordinator",
  model: "gemini-2.5-flash",
  description: "Routes requests to appropriate specialists",
  instruction:
    "Use 'billing' for payment issues, 'support' for login/tech problems.",
  subAgents: [billing, support],
});
// With AutoFlow, the model can transfer to sub-agents via generated transfer calls
```

#### Explicit Invocation (AgentTool)

Wrap an agent as a tool for explicit, synchronous calls with clear contracts.

- Deterministic invocation (no routing ambiguity), explicit schemas via tools
- Returned content and state deltas flow back to the callerâ€™s session
- Name tools distinctly (e.g., `research_assistant_tool`) for clarity in traces

```ts
import { AgentTool, LlmAgent } from "@iqai/adk";

const webSearch = new LlmAgent({
  name: "web_search",
  description: "Searches the web",
});
const summarizer = new LlmAgent({
  name: "summarizer",
  description: "Summarizes text",
});

const researchAssistant = new LlmAgent({
  name: "research_assistant",
  description: "Finds and summarizes information",
  tools: [
    new AgentTool({ name: "web_search_tool", agent: webSearch }),
    new AgentTool({ name: "summarizer_tool", agent: summarizer }),
  ],
});

const reportWriter = new LlmAgent({
  name: "report_writer",
  instruction:
    "Use the research assistant tool to gather information before writing.",
  tools: [
    new AgentTool({
      name: "research_assistant_tool",
      agent: researchAssistant,
    }),
  ],
});
```

## Common Multi-Agent Patterns

### Coordinator/Dispatcher Pattern

A central agent routes requests to appropriate specialists based on content analysis and domain expertise.

**Structure**: Central coordinator with specialist sub-agents

**Communication**: LLM-driven delegation or AgentTool invocation

**Best for**: Customer service, help desk systems, domain-specific routing

```typescript
const billingSpecialist = new LlmAgent({
  name: "billing-specialist",
  description: "Handles billing, payments, refunds, and invoice issues",
});

const technicalSupport = new LlmAgent({
  name: "technical-support",
  description: "Resolves technical issues, bugs, and system problems",
});

const generalSupport = new LlmAgent({
  name: "general-support",
  description:
    "Handles general inquiries, account questions, and information requests",
});

// Coordinator routes using LLM-driven delegation
const serviceCoordinator = new LlmAgent({
  name: "service-coordinator",
  instruction: `
    Route customer requests to appropriate specialists:
    - Billing/payment issues â†’ billing-specialist
    - Technical problems â†’ technical-support  
    - General questions â†’ general-support
  `,
  subAgents: [billingSpecialist, technicalSupport, generalSupport],
});
```

### Sequential Pipeline Pattern

Multi-step workflows where each agent processes results from the previous step in a fixed order.

**Structure**: SequentialAgent with ordered sub-agents

**Communication**: Shared session state with outputKey flow

**Best for**: Data processing, validation workflows, content generation pipelines

```typescript
const dataValidator = new LlmAgent({
  name: "data-validator",
  instruction: "Validate input data format and completeness",
  outputKey: "validation_result",
});

const dataProcessor = new LlmAgent({
  name: "data-processor",
  instruction: "Process data if {validation_result} indicates valid input",
  outputKey: "processed_data",
});

const reportGenerator = new LlmAgent({
  name: "report-generator",
  instruction: "Generate comprehensive report from {processed_data}",
  outputKey: "final_report",
});

const dataProcessingPipeline = new SequentialAgent({
  name: "data-processing-pipeline",
  description: "Validates, processes, and reports on input data",
  subAgents: [dataValidator, dataProcessor, reportGenerator],
});
```

### Parallel Fan-Out/Gather Pattern

Execute independent tasks concurrently, then aggregate results. Often implemented as parallel execution followed by sequential synthesis.

**Structure**: ParallelAgent nested within SequentialAgent

**Communication**: Concurrent state writes with distinct keys, followed by multi-key consumption

**Best for**: API calls, research from multiple sources, independent analysis tasks

```typescript
const webDataFetcher = new LlmAgent({
  name: "web-data-fetcher",
  instruction: "Fetch current web information about the topic",
  outputKey: "web_data",
});

const apiDataFetcher = new LlmAgent({
  name: "api-data-fetcher",
  instruction: "Retrieve structured API data for the topic",
  outputKey: "api_data",
});

const databaseQuery = new LlmAgent({
  name: "database-query",
  instruction: "Query internal database for historical data",
  outputKey: "db_data",
});

// Parallel data gathering
const dataGathering = new ParallelAgent({
  name: "concurrent-data-gathering",
  subAgents: [webDataFetcher, apiDataFetcher, databaseQuery],
});

// Sequential synthesis of gathered data
const dataSynthesizer = new LlmAgent({
  name: "data-synthesizer",
  instruction:
    "Combine and analyze {web_data}, {api_data}, and {db_data} into comprehensive insights",
  outputKey: "synthesized_analysis",
});

const gatherAndSynthesize = new SequentialAgent({
  name: "gather-and-synthesize-workflow",
  subAgents: [dataGathering, dataSynthesizer],
});
```

### Hierarchical Task Decomposition

Break complex goals into specialized sub-tasks across multiple levels using AgentTool for reusable capabilities.

**Structure**: Multi-level hierarchy with AgentTool composition

**Communication**: Explicit invocation with structured contracts

**Best for**: Complex research, analysis workflows, reusable capability composition

```typescript
// Level 1: Basic capabilities
const webSearcher = new LlmAgent({
  name: "web-searcher",
  description: "Searches web for current information",
});

const dataSummarizer = new LlmAgent({
  name: "data-summarizer",
  description: "Summarizes and extracts key points from text",
});

// Level 2: Composed capabilities
const researchAssistant = new LlmAgent({
  name: "research-assistant",
  description: "Conducts comprehensive research on topics",
  tools: [
    new AgentTool({ name: "web_search", agent: webSearcher }),
    new AgentTool({ name: "summarize", agent: dataSummarizer }),
  ],
});

const contentAnalyzer = new LlmAgent({
  name: "content-analyzer",
  description: "Analyzes content for insights and patterns",
  tools: [new AgentTool({ name: "research", agent: researchAssistant })],
});

// Level 3: High-level orchestration
const reportWriter = new LlmAgent({
  name: "report-writer",
  instruction:
    "Create comprehensive reports using research and analysis capabilities",
  tools: [
    new AgentTool({ name: "research_tool", agent: researchAssistant }),
    new AgentTool({ name: "analysis_tool", agent: contentAnalyzer }),
  ],
});
```

### Review/Critique Pattern (Generator-Critic)

Improve output quality through structured generation and review cycles.

**Structure**: SequentialAgent with generator and critic agents

**Communication**: Shared state for draft content and review feedback

**Best for**: Content quality improvement, code review, fact-checking workflows

```typescript
const contentGenerator = new LlmAgent({
  name: "content-generator",
  instruction: "Generate initial content based on requirements and context",
  outputKey: "draft_content",
});

const contentCritic = new LlmAgent({
  name: "content-critic",
  instruction: `
    Review {draft_content} for:
    - Factual accuracy and completeness
    - Clarity and readability  
    - Adherence to requirements
    Output detailed feedback and improvement suggestions.
  `,
  outputKey: "review_feedback",
});

const contentRefiner = new LlmAgent({
  name: "content-refiner",
  instruction: "Improve {draft_content} based on {review_feedback}",
  outputKey: "refined_content",
});

const generateAndReview = new SequentialAgent({
  name: "generate-review-refine",
  description: "Generate, critique, and refine content for quality",
  subAgents: [contentGenerator, contentCritic, contentRefiner],
});
```

### Iterative Refinement Pattern

Continuously improve results through repeated refinement cycles until quality criteria are met.

**Structure**: LoopAgent with refinement and quality assessment agents

**Communication**: Persistent state across iterations with escalation control

**Best for**: Code improvement, iterative design, optimization workflows

```typescript
import { LoopAgent, BaseAgent, Event, EventActions } from "@iqai/adk";

const codeRefiner = new LlmAgent({
  name: "code-refiner",
  instruction:
    "Improve code quality, performance, and readability based on current {code} and {requirements}",
  outputKey: "code",
});

const qualityAssessor = new LlmAgent({
  name: "quality-assessor",
  instruction:
    "Evaluate {code} against {requirements}. Output 'pass' if satisfactory, 'fail' if needs improvement",
  outputKey: "quality_status",
});

// Custom agent to check status and escalate when quality passes
class QualityGate extends BaseAgent {
  constructor() {
    super({
      name: "quality-gate",
      description: "Controls iteration termination",
    });
  }

  protected async *runAsyncImpl(ctx: InvocationContext) {
    const status = ctx.session.state.get("quality_status", "fail");
    const shouldStop = status === "pass";
    yield new Event({
      author: this.name,
      actions: new EventActions({ escalate: shouldStop }),
    });
  }
}

const iterativeRefinement = new LoopAgent({
  name: "iterative-code-refinement",
  maxIterations: 5, // Safety limit
  subAgents: [codeRefiner, qualityAssessor, new QualityGate()],
});
```

### Human-in-the-Loop Pattern

Integrate human oversight and approval into automated agent workflows using custom tools that interface with external systems.

**Structure**: Custom tools that pause execution and request human input

**Communication**: External system integration with approval workflows

**Best for**: Compliance requirements, quality gates, creative approval processes

```typescript
import { createTool } from "@iqai/adk";
import { z } from "zod";

// Tool that integrates with external approval system
const humanApprovalTool = createTool({
  name: "request_human_approval",
  description: "Request human approval for critical decisions",
  schema: z.object({
    decision: z.string(),
    reasoning: z.string(),
    urgency: z.enum(["low", "medium", "high"]),
  }),
  fn: async ({ decision, reasoning, urgency }) => {
    // Integration with ticketing system, Slack, email, etc.
    const approvalRequest = await sendApprovalRequest({
      decision,
      reasoning,
      urgency,
      timestamp: new Date().toISOString(),
    });

    // Wait for human response (polling, webhook, etc.)
    const response = await waitForApproval(approvalRequest.id);

    return {
      approved: response.approved,
      feedback: response.feedback,
      approver: response.approver,
    };
  },
});

const complianceWorkflow = new SequentialAgent({
  name: "compliance-workflow",
  description: "Automated workflow with human approval gates",
  subAgents: [
    new LlmAgent({
      name: "risk-assessor",
      instruction: "Assess risk and prepare approval request",
      outputKey: "risk_assessment",
    }),
    new LlmAgent({
      name: "approval-requester",
      instruction:
        "Request approval for {risk_assessment} using human approval tool",
      tools: [humanApprovalTool],
      outputKey: "approval_result",
    }),
    new LlmAgent({
      name: "executor",
      instruction: "Execute decision if {approval_result} indicates approval",
    }),
  ],
});
```

## Best Practices

### Design Principles

**Single Responsibility**: Keep each agent focused on one clear domain or task

- Billing agents handle payments, support agents handle technical issues
- Avoid agents that try to do everything - prefer composition over complexity

**Clear Boundaries**: Define explicit inputs, outputs, and state contracts

- Use consistent state key naming (`user_profile`, `analysis_result`, `validation_status`)
- Document state dependencies and communication patterns
- Validate state presence before consumption

**Hierarchy Management**: Structure agent relationships thoughtfully

- Establish clear parent-child relationships with `subAgents`
- Remember the single parent rule - agents can only have one parent
- Use descriptive agent names for easy navigation with `findAgent(name)`

### Communication Strategy

**State Management**: Design state flow carefully across agents

- Use distinct state keys in parallel branches to avoid conflicts
- Consider temporary vs persistent state needs
- Implement state validation and default values

**Transfer Routing**: Write clear routing instructions for LLM delegation

- Provide specific mapping rules in coordinator instructions
- Use non-overlapping agent descriptions for better routing decisions
- Test routing with representative user inputs

**Tool Integration**: Design AgentTool contracts for reusability

- Name tools descriptively (`research_tool`, `analysis_tool`)
- Consider structured schemas for complex tool interactions
- Plan for tool result handling and error cases

### Production Considerations

**Error Handling**: Plan for failures and edge cases

- Implement timeout handling for long-running agents
- Design retry logic for transient failures
- Create escalation paths for unhandled errors

**Performance**: Optimize for scale and efficiency

- Control concurrency in parallel operations
- Cache results where appropriate to avoid redundant work
- Monitor resource usage and external API limits

**Observability**: Implement comprehensive monitoring

- Use callbacks for execution tracking and metrics
- Log state transitions and agent interactions
- Track performance metrics and failure rates

### Testing Strategy

**Unit Testing**: Test individual agents in isolation

- Mock external dependencies and sub-agents
- Verify state handling and output consistency
- Test error conditions and edge cases

**Integration Testing**: Validate multi-agent workflows end-to-end

- Test complete user journeys through agent systems
- Verify state flow between agents and workflow steps
- Validate communication patterns and routing decisions

**Load Testing**: Ensure performance under realistic conditions

- Test concurrent execution with ParallelAgent
- Validate resource usage and memory management
- Monitor external API usage and rate limiting

## Related Topics

<Cards>
  <Card
    title="Sessions"
    description="Manage state and context across multi-agent workflows"
    href="/docs/framework/sessions"
  />

<Card
  title="Workflow Agents"
  description="Learn orchestration patterns"
  href="/docs/framework/agents/workflow-agents"
/>

<Card
  title="Callbacks"
  description="Monitor and control execution"
  href="/docs/framework/callbacks"
/>

  <Card
    title="Examples"
    description="Explore multi-agent implementations"
    href="https://github.com/IQAIcom/adk-ts/tree/main/apps/examples"
    target="_blank"
    rel="noopener noreferrer"
  />
</Cards>
```
