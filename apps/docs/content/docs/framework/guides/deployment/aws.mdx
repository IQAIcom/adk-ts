---
title: AWS
description: Deploy ADK-TS agents to AWS using Lambda, ECS Fargate, or EC2
---

import { Callout } from "fumadocs-ui/components/callout";
import { Tab, Tabs } from "fumadocs-ui/components/tabs";
import { Accordion, Accordions } from "fumadocs-ui/components/accordion";

AWS offers multiple deployment options for ADK-TS agents, from serverless functions to fully managed containers and virtual machines. Choose based on your execution requirements and operational preferences.

## When to Use AWS

Choose AWS when you need:

- **Enterprise-grade infrastructure** with comprehensive compliance certifications
- **Flexible deployment options** (serverless, containers, VMs)
- **Integration with AWS services** (S3, DynamoDB, RDS, etc.)
- **Global infrastructure** with 30+ regions worldwide
- **Fine-grained cost control** and reserved capacity pricing
- **Advanced monitoring** with CloudWatch and X-Ray

**Not sure?** See the [Platform Comparison](/docs/guides/deployment#platform-comparison) to compare AWS with Railway, Vercel, and Docker options.

## Deployment Options Overview

AWS provides three primary deployment paths for ADK-TS agents:

| Option | Best For | Execution Time | Complexity | Cost Model |
|--------|----------|----------------|------------|------------|
| **Lambda** | API endpoints, webhooks, short tasks | 15 minutes max | Low | Pay-per-invocation |
| **ECS Fargate** | Long-running agents, Discord bots, background tasks | Unlimited | Medium | Pay-per-hour (running containers) |
| **EC2** | High-scale, custom infrastructure, cost optimization | Unlimited | High | Pay-per-hour (instance uptime) |

## Choose Your Deployment Method

<Tabs items={['Lambda', 'ECS Fargate', 'EC2']}>
  <Tab value="Lambda">
    **AWS Lambda (Serverless API Agents)**

    AWS Lambda is a serverless compute service for running code in response to events. **Best for**: API-based agents, webhook handlers, and request-response workflows with execution under 15 minutes.

    **When to Use Lambda**

    Use Lambda when your agent:

    - Responds to HTTP requests (API Gateway, webhooks)
    - Has predictable, short-lived executions (under 15 minutes)
    - Benefits from automatic scaling (0 to thousands of requests)
    - Needs pay-per-invocation pricing (no idle costs)
    - Can use stateless execution model

    **Not suitable for:**

    - Always-on Discord/Telegram bots (use ECS Fargate instead)
    - Long-running tasks over 15 minutes (use ECS Fargate or EC2)
    - Stateful applications requiring persistent connections
    - Tasks requiring large compute resources (10GB memory limit)

    **Prerequisites**

    - **AWS Account** with appropriate permissions
    - **AWS CLI** installed and configured ([guide](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html))
    - **Docker** installed for container image builds
    - **Built and tested** API-based ADK-TS agent locally

    **Deployment Steps**

    <Accordions>
      <Accordion title="Step 1: Create Dockerfile for Lambda">
        Lambda supports container images up to 10GB. Create a Lambda-compatible Dockerfile:

        ```dockerfile
        # Use AWS Lambda Node.js 24 base image
        FROM public.ecr.aws/lambda/nodejs:24

        # Enable pnpm
        RUN corepack enable && corepack prepare pnpm@9.12.0 --activate

        # Copy package files
        COPY package.json pnpm-lock.yaml ./

        # Install production dependencies
        RUN pnpm install --frozen-lockfile --prod

        # Copy TypeScript config and source
        COPY tsconfig.json ./
        COPY src ./src

        # Build TypeScript
        RUN pnpm install --frozen-lockfile && pnpm build

        # Copy compiled code to Lambda task root
        COPY --from=builder ${LAMBDA_TASK_ROOT}/dist ${LAMBDA_TASK_ROOT}/

        # Set the Lambda handler
        CMD [ "index.handler" ]
        ```
      </Accordion>

      <Accordion title="Step 2: Create Lambda Handler">
        Create `src/index.ts` with Lambda handler:

        ```typescript
        import { AgentBuilder } from "@iqai/adk";
        import type { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";

        export const handler = async (
          event: APIGatewayProxyEvent
        ): Promise<APIGatewayProxyResult> => {
          // Parse request body
          const body = JSON.parse(event.body || "{}");
          const { message } = body;

          if (!message) {
            return {
              statusCode: 400,
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ error: "Message is required" }),
            };
          }

          try {
            // Create ADK-TS agent
            const agent = new AgentBuilder()
              .withModel(process.env.LLM_MODEL || "gpt-4")
              .withInstruction("You are a helpful assistant")
              .buildLlm();

            // Process request
            const response = await agent.ask(message);

            return {
              statusCode: 200,
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ response }),
            };
          } catch (error) {
            console.error("Agent error:", error);
            return {
              statusCode: 500,
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ error: "Internal server error" }),
            };
          }
        };
        ```
      </Accordion>

      <Accordion title="Step 3: Build and Push Docker Image">
        ```bash
        # Build for Lambda (AMD64 architecture)
        docker buildx build --platform linux/amd64 -t adk-agent-lambda:latest .

        # Authenticate to ECR (replace REGION and ACCOUNT_ID)
        aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin ACCOUNT_ID.dkr.ecr.us-east-1.amazonaws.com

        # Create ECR repository (if it doesn't exist)
        aws ecr create-repository --repository-name adk-agent-lambda --region us-east-1

        # Tag image for ECR
        docker tag adk-agent-lambda:latest ACCOUNT_ID.dkr.ecr.us-east-1.amazonaws.com/adk-agent-lambda:latest

        # Push to ECR
        docker push ACCOUNT_ID.dkr.ecr.us-east-1.amazonaws.com/adk-agent-lambda:latest
        ```
      </Accordion>

      <Accordion title="Step 4: Create Lambda Function">
        ```bash
        # Create Lambda function from container image
        aws lambda create-function \
          --function-name adk-agent \
          --package-type Image \
          --code ImageUri=ACCOUNT_ID.dkr.ecr.us-east-1.amazonaws.com/adk-agent-lambda:latest \
          --role arn:aws:iam::ACCOUNT_ID:role/lambda-execution-role \
          --timeout 900 \
          --memory-size 2048 \
          --region us-east-1
        ```

        <Callout type="info" title="Execution Role Required">
          Create an IAM role with Lambda execution permissions and any additional
          permissions your agent needs (S3, DynamoDB, etc.). See [AWS Lambda execution role documentation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-intro-execution-role.html).
        </Callout>
      </Accordion>

      <Accordion title="Step 5: Set Environment Variables">
        See [Environment Variables](/docs/guides/deployment#environment-variables) for common ADK-TS variables.

        ```bash
        aws lambda update-function-configuration \
          --function-name adk-agent \
          --environment "Variables={
            OPENAI_API_KEY=sk-...,
            LLM_MODEL=gpt-4,
            NODE_ENV=production
          }" \
          --region us-east-1
        ```
      </Accordion>

      <Accordion title="Step 6: Create API Gateway (Optional)">
        Expose Lambda via HTTP endpoint:

        ```bash
        # Create REST API
        aws apigateway create-rest-api \
          --name "ADK Agent API" \
          --region us-east-1

        # Configure API Gateway integration (see AWS documentation for detailed steps)
        ```

        Or use AWS Console to create an HTTP API with Lambda integration.
      </Accordion>
    </Accordions>

    **Testing Lambda Deployment**

    Invoke Lambda directly:

    ```bash
    aws lambda invoke \
      --function-name adk-agent \
      --payload '{"body": "{\"message\": \"Hello, what can you do?\"}"}' \
      --region us-east-1 \
      response.json

    cat response.json
    ```

    Or test via API Gateway endpoint:

    ```bash
    curl -X POST https://your-api-id.execute-api.us-east-1.amazonaws.com/prod/chat \
      -H "Content-Type: application/json" \
      -d '{"message": "Hello, what can you do?"}'
    ```

    **Updating Lambda Deployment**

    ```bash
    # Rebuild and push new image
    docker buildx build --platform linux/amd64 -t adk-agent-lambda:latest .
    docker tag adk-agent-lambda:latest ACCOUNT_ID.dkr.ecr.us-east-1.amazonaws.com/adk-agent-lambda:latest
    docker push ACCOUNT_ID.dkr.ecr.us-east-1.amazonaws.com/adk-agent-lambda:latest

    # Update Lambda function
    aws lambda update-function-code \
      --function-name adk-agent \
      --image-uri ACCOUNT_ID.dkr.ecr.us-east-1.amazonaws.com/adk-agent-lambda:latest \
      --region us-east-1
    ```
  </Tab>

  <Tab value="ECS Fargate">
    **AWS ECS Fargate (Managed Containers)**

    AWS ECS (Elastic Container Service) with Fargate is a fully managed container orchestration service. **Best for**: Long-running agents, Discord bots, background tasks, and stateful applications.

    **When to Use ECS Fargate**

    Use ECS Fargate when your agent:

    - Runs continuously (Discord bots, Telegram bots, background workers)
    - Needs persistent connections or stateful execution
    - Requires execution beyond 15 minutes
    - Benefits from managed container orchestration
    - Needs auto-scaling based on metrics

    **Not suitable for:**

    - Simple API endpoints with low traffic (use Lambda instead)
    - Maximum cost optimization (use EC2 with reserved instances)

    **Prerequisites**

    - **AWS Account** with appropriate permissions
    - **AWS CLI** installed and configured
    - **Docker** installed
    - **AWS Copilot CLI** installed (recommended) - [installation guide](https://aws.github.io/copilot-cli/docs/getting-started/install/)

    **Deployment Methods**

    <Tabs items={['AWS Copilot (Recommended)', 'AWS CDK (Advanced)']}>
      <Tab value="AWS Copilot (Recommended)">
        AWS Copilot CLI simplifies ECS deployment with infrastructure as code.

        <Accordions>
          <Accordion title="Step 1: Initialize Copilot Application">
            ```bash
            # Navigate to your project directory
            cd your-adk-agent

            # Initialize Copilot application
            copilot app init adk-agent-app
            ```
          </Accordion>

          <Accordion title="Step 2: Create Service">
            ```bash
            # Create a backend service (long-running)
            copilot svc init \
              --name agent-service \
              --svc-type "Backend Service" \
              --dockerfile ./Dockerfile
            ```

            This creates:
            - `copilot/agent-service/manifest.yml` - Service configuration
            - Infrastructure definitions for ECS, VPC, load balancer
          </Accordion>

          <Accordion title="Step 3: Configure Service Manifest">
            Edit `copilot/agent-service/manifest.yml`:

            ```yaml
            name: agent-service
            type: Backend Service

            # Docker image configuration
            image:
              build: Dockerfile

            # CPU and memory (256 CPU = 0.25 vCPU)
            cpu: 512
            memory: 1024

            # Number of tasks
            count: 1

            # Environment variables
            variables:
              NODE_ENV: production
              LLM_MODEL: gpt-4

            # Secrets from AWS Systems Manager Parameter Store
            secrets:
              OPENAI_API_KEY: /copilot/adk-agent-app/production/secrets/OPENAI_API_KEY
              DISCORD_TOKEN: /copilot/adk-agent-app/production/secrets/DISCORD_TOKEN

            # Auto-scaling configuration (optional)
            # count:
            #   range: 1-5
            #   cpu_percentage: 70
            #   memory_percentage: 80
            ```
          </Accordion>

          <Accordion title="Step 4: Store Secrets">
            ```bash
            # Store secrets in AWS Systems Manager Parameter Store
            aws ssm put-parameter \
              --name /copilot/adk-agent-app/production/secrets/OPENAI_API_KEY \
              --value "sk-..." \
              --type SecureString \
              --region us-east-1

            aws ssm put-parameter \
              --name /copilot/adk-agent-app/production/secrets/DISCORD_TOKEN \
              --value "your-discord-token" \
              --type SecureString \
              --region us-east-1
            ```
          </Accordion>

          <Accordion title="Step 5: Deploy to ECS Fargate">
            ```bash
            # Deploy to production environment
            copilot deploy --name agent-service --env production
            ```

            Copilot will:
            - Build your Docker image
            - Push to Amazon ECR
            - Create ECS cluster, task definition, and service
            - Deploy your agent to Fargate
          </Accordion>

          <Accordion title="Step 6: Verify Deployment">
            ```bash
            # Check service status
            copilot svc status --name agent-service

            # View logs
            copilot svc logs --name agent-service --follow

            # Show service details
            copilot svc show --name agent-service
            ```
          </Accordion>
        </Accordions>

        **Updating ECS Deployment**

        ```bash
        # Make code changes, then redeploy
        copilot deploy --name agent-service --env production
        ```

        **Monitoring**

        View logs in CloudWatch:

        ```bash
        # With Copilot
        copilot svc logs --name agent-service --follow

        # With AWS CLI
        aws logs tail /ecs/adk-agent --follow --region us-east-1
        ```
      </Tab>

      <Tab value="AWS CDK (Advanced)">
        For more control, use AWS CDK (Cloud Development Kit) with TypeScript.

        <Accordions>
          <Accordion title="Step 1: Install CDK">
            ```bash
            npm install -g aws-cdk
            ```
          </Accordion>

          <Accordion title="Step 2: Initialize CDK Project">
            ```bash
            mkdir adk-agent-infrastructure
            cd adk-agent-infrastructure
            cdk init app --language typescript
            ```
          </Accordion>

          <Accordion title="Step 3: Define Infrastructure">
            Edit `lib/adk-agent-infrastructure-stack.ts`:

            ```typescript
            import * as cdk from "aws-cdk-lib";
            import * as ecs from "aws-cdk-lib/aws-ecs";
            import * as ec2 from "aws-cdk-lib/aws-ec2";
            import * as logs from "aws-cdk-lib/aws-logs";
            import { Construct } from "constructs";

            export class AdkAgentInfrastructureStack extends cdk.Stack {
              constructor(scope: Construct, id: string, props?: cdk.StackProps) {
                super(scope, id, props);

                // Create VPC
                const vpc = new ec2.Vpc(this, "AdkAgentVpc", {
                  maxAzs: 2,
                });

                // Create ECS Cluster
                const cluster = new ecs.Cluster(this, "AdkAgentCluster", {
                  vpc,
                  clusterName: "adk-agent-cluster",
                });

                // Create Fargate Task Definition
                const taskDefinition = new ecs.FargateTaskDefinition(this, "AgentTaskDef", {
                  memoryLimitMiB: 1024,
                  cpu: 512,
                });

                // Add container to task
                const container = taskDefinition.addContainer("AgentContainer", {
                  image: ecs.ContainerImage.fromRegistry(
                    "ACCOUNT_ID.dkr.ecr.us-east-1.amazonaws.com/adk-agent:latest"
                  ),
                  logging: ecs.LogDrivers.awsLogs({
                    streamPrefix: "adk-agent",
                    logRetention: logs.RetentionDays.ONE_WEEK,
                  }),
                  environment: {
                    NODE_ENV: "production",
                    LLM_MODEL: "gpt-4",
                  },
                  secrets: {
                    OPENAI_API_KEY: ecs.Secret.fromSecretsManager(
                      // Reference to Secrets Manager secret
                    ),
                  },
                });

                // Create Fargate Service
                new ecs.FargateService(this, "AgentService", {
                  cluster,
                  taskDefinition,
                  desiredCount: 1,
                  serviceName: "adk-agent-service",
                });
              }
            }
            ```
          </Accordion>

          <Accordion title="Step 4: Deploy CDK Stack">
            ```bash
            # Bootstrap CDK (first time only)
            cdk bootstrap

            # Deploy stack
            cdk deploy
            ```
          </Accordion>
        </Accordions>

        **Updating ECS Deployment**

        ```bash
        # Update infrastructure code, then redeploy
        cdk deploy
        ```
      </Tab>
    </Tabs>
  </Tab>

  <Tab value="EC2">
    **AWS EC2 (Virtual Machines)**

    AWS EC2 provides virtual servers with full control over the operating system and configuration. **Best for**: High-scale deployments, cost optimization with reserved instances, and custom infrastructure requirements.

    **When to Use EC2**

    Use EC2 when you need:

    - **Maximum control** over infrastructure and configuration
    - **Cost optimization** with reserved instances or spot instances
    - **High-scale deployments** with predictable workloads
    - **Custom system dependencies** not available in containers
    - **24/7 persistent workloads** with long-term commitments

    **Not suitable for:**

    - Simple deployments (use Lambda or ECS Fargate instead)
    - Variable workloads (Lambda or Fargate scale better)
    - If you want to avoid infrastructure management

    **Prerequisites**

    - **AWS Account** with EC2 permissions
    - **SSH key pair** for instance access
    - **Security group** configured for your agent's requirements

    **Deployment Steps**

    <Accordions>
      <Accordion title="Step 1: Launch EC2 Instance">
        **Using AWS CLI:**

        ```bash
        # Launch Ubuntu 24.04 LTS instance
        aws ec2 run-instances \
          --image-id ami-0c55b159cbfafe1f0 \
          --instance-type t3.medium \
          --key-name your-key-pair \
          --security-group-ids sg-your-security-group \
          --subnet-id subnet-your-subnet \
          --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value=adk-agent}]' \
          --region us-east-1
        ```

        **Or use AWS Console:**
        - **AMI**: Ubuntu 24.04 LTS
        - **Instance Type**: t3.medium (2 vCPU, 4GB RAM) or larger
        - **Storage**: 20GB+ gp3 SSD
      </Accordion>

      <Accordion title="Step 2: Connect to Instance">
        ```bash
        # SSH into instance
        ssh -i your-key-pair.pem ubuntu@your-instance-public-ip
        ```
      </Accordion>

      <Accordion title="Step 3: Install Dependencies">
        ```bash
        # Update system
        sudo apt update && sudo apt upgrade -y

        # Install Node.js 22
        curl -fsSL https://deb.nodesource.com/setup_22.x | sudo -E bash -
        sudo apt install -y nodejs

        # Install pnpm
        sudo corepack enable
        sudo corepack prepare pnpm@9.12.0 --activate

        # Install build tools
        sudo apt install -y build-essential git

        # Install Docker (optional, if using Docker deployment)
        curl -fsSL https://get.docker.com | sudo sh
        sudo usermod -aG docker ubuntu
        ```
      </Accordion>

      <Accordion title="Step 4: Deploy Your Agent">
        <Tabs items={['Direct Node.js', 'Docker']}>
          <Tab value="Direct Node.js">
            ```bash
            # Clone your repository
            git clone https://github.com/your-username/your-adk-agent.git
            cd your-adk-agent

            # Install dependencies
            pnpm install --frozen-lockfile

            # Build TypeScript
            pnpm build

            # Create .env file
            nano .env
            # Add your environment variables (see Environment Variables section)

            # Start agent with PM2 (process manager)
            sudo npm install -g pm2
            pm2 start dist/index.js --name adk-agent
            pm2 save
            pm2 startup
            ```
          </Tab>

          <Tab value="Docker">
            ```bash
            # Clone your repository
            git clone https://github.com/your-username/your-adk-agent.git
            cd your-adk-agent

            # Build Docker image
            docker buildx build --platform linux/amd64 -t adk-agent:latest .

            # Run container
            docker run -d \
              --name adk-agent \
              --restart unless-stopped \
              --env-file .env \
              -p 3000:3000 \
              adk-agent:latest

            # View logs
            docker logs -f adk-agent
            ```
          </Tab>
        </Tabs>
      </Accordion>

      <Accordion title="Step 5: Configure Auto-Start">
        <Tabs items={['PM2', 'Docker', 'systemd']}>
          <Tab value="PM2">
            ```bash
            # PM2 automatically configures startup script
            pm2 startup
            pm2 save
            ```
          </Tab>

          <Tab value="Docker">
            ```bash
            # Docker restart policy handles auto-start
            docker update --restart unless-stopped adk-agent
            ```
          </Tab>

          <Tab value="systemd">
            Create `/etc/systemd/system/adk-agent.service`:

            ```ini
            [Unit]
            Description=ADK-TS Agent
            After=network.target

            [Service]
            Type=simple
            User=ubuntu
            WorkingDirectory=/home/ubuntu/your-adk-agent
            ExecStart=/usr/bin/node dist/index.js
            Restart=always
            RestartSec=10
            Environment=NODE_ENV=production
            EnvironmentFile=/home/ubuntu/your-adk-agent/.env

            [Install]
            WantedBy=multi-user.target
            ```

            Enable and start:

            ```bash
            sudo systemctl enable adk-agent
            sudo systemctl start adk-agent
            sudo systemctl status adk-agent
            ```
          </Tab>
        </Tabs>
      </Accordion>
    </Accordions>

    **Monitoring EC2 Deployment**

    <Tabs items={['PM2', 'Docker', 'systemd', 'CloudWatch']}>
      <Tab value="PM2">
        ```bash
        pm2 logs adk-agent
        pm2 monit  # Real-time monitoring
        ```
      </Tab>

      <Tab value="Docker">
        ```bash
        docker logs -f adk-agent
        ```
      </Tab>

      <Tab value="systemd">
        ```bash
        journalctl -u adk-agent -f
        ```
      </Tab>

      <Tab value="CloudWatch">
        Install CloudWatch agent to send logs and metrics to AWS CloudWatch:

        ```bash
        wget https://s3.amazonaws.com/amazoncloudwatch-agent/ubuntu/amd64/latest/amazon-cloudwatch-agent.deb
        sudo dpkg -i amazon-cloudwatch-agent.deb

        # Configure and start CloudWatch agent
        # See: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Install-CloudWatch-Agent.html
        ```
      </Tab>
    </Tabs>

    **Updating EC2 Deployment**

    ```bash
    # SSH into instance
    ssh -i your-key-pair.pem ubuntu@your-instance-public-ip

    # Pull latest code
    cd your-adk-agent
    git pull origin main

    # Rebuild and restart
    pnpm install --frozen-lockfile
    pnpm build

    # Restart with PM2
    pm2 restart adk-agent

    # Or with Docker
    docker stop adk-agent
    docker rm adk-agent
    docker buildx build -t adk-agent:latest .
    docker run -d --name adk-agent --restart unless-stopped --env-file .env adk-agent:latest
    ```
  </Tab>
</Tabs>

## Environment Variables

See [Environment Variables](/docs/guides/deployment#environment-variables) for a complete list of common ADK-TS variables and security best practices.

**AWS-Specific Environment Variable Management**

<Tabs items={['Lambda', 'ECS Fargate', 'EC2']}>
  <Tab value="Lambda">
    - Set via `aws lambda update-function-configuration --environment`
    - Or use AWS Console → Lambda → Configuration → Environment variables
    - Encrypted at rest automatically
  </Tab>

  <Tab value="ECS Fargate">
    - Store secrets in AWS Systems Manager Parameter Store or Secrets Manager
    - Reference in task definition with `secrets` field
    - Never use plain `environment` field for sensitive data
  </Tab>

  <Tab value="EC2">
    - Use `.env` file with proper permissions (`chmod 600 .env`)
    - Or use AWS Systems Manager Parameter Store and fetch at runtime
    - Or use instance metadata service for IAM role credentials
  </Tab>
</Tabs>

**Fetching Secrets from Parameter Store (EC2/ECS)**

```typescript
import { SSMClient, GetParameterCommand } from "@aws-sdk/client-ssm";

const client = new SSMClient({ region: "us-east-1" });

async function getSecret(name: string): Promise<string> {
  const command = new GetParameterCommand({
    Name: name,
    WithDecryption: true,
  });

  const response = await client.send(command);
  return response.Parameter?.Value || "";
}

// Usage
const apiKey = await getSecret("/adk-agent/production/OPENAI_API_KEY");
```

## Troubleshooting

See [Common Troubleshooting](/docs/guides/deployment#common-troubleshooting) for general deployment issues.

**AWS-Specific Issues**

<Accordions>
  <Accordion title="Lambda Container Image Too Large">
    **Problem**: Image exceeds 10GB limit

    **Solutions**:
    - Use multi-stage builds to reduce image size
    - Remove unnecessary dependencies from production
    - Use Lambda layers for common dependencies
    - Consider ECS Fargate for larger images
  </Accordion>

  <Accordion title="Lambda Timeout (15 minutes)">
    **Problem**: Agent execution exceeds 15-minute limit

    **Solutions**:
    - Optimize agent processing time
    - Split work into smaller tasks
    - Use ECS Fargate or EC2 for long-running tasks
    - Implement async processing with SQS + Lambda
  </Accordion>

  <Accordion title="ECS Task Failing to Start">
    **Problem**: Task transitions from PENDING to STOPPED

    **Solutions**:
    - Check CloudWatch logs for errors
    - Verify ECR image URI is correct
    - Ensure task execution role has ECR pull permissions
    - Check CPU/memory limits are sufficient
    - Verify secrets exist in Parameter Store/Secrets Manager
  </Accordion>

  <Accordion title="ECS Out of Memory">
    **Problem**: Task killed due to memory exhaustion

    **Solutions**:
    - Increase task memory limit in manifest.yml or task definition
    - Monitor memory usage with CloudWatch Container Insights
    - Optimize agent memory usage
    - Use larger Fargate task size
  </Accordion>

  <Accordion title="EC2 Connection Timeout">
    **Problem**: Cannot SSH into EC2 instance

    **Solutions**:
    - Verify security group allows SSH (port 22) from your IP
    - Check instance is in running state
    - Verify correct key pair is used
    - Check network ACLs and route tables
  </Accordion>

  <Accordion title="High AWS Costs">
    **Problem**: Unexpected AWS charges

    **Solutions**:
    - Review CloudWatch metrics and billing dashboard
    - Stop unused EC2 instances
    - Use Lambda for intermittent workloads
    - Implement auto-scaling to match demand
    - Consider reserved instances for predictable workloads
    - Use cost allocation tags to track spending
  </Accordion>
</Accordions>

## Best Practices

See [General Best Practices](/docs/guides/deployment#general-best-practices) for universal deployment guidance.

**AWS-Specific Best Practices**

<Accordions>
  <Accordion title="Cost Optimization">
    - Use Lambda for intermittent, request-driven workloads
    - Use ECS Fargate for consistent, long-running tasks
    - Use EC2 reserved instances for predictable 24/7 workloads
    - Implement auto-scaling to match actual demand
    - Use Savings Plans for long-term commitments
    - Monitor costs with AWS Cost Explorer and budgets
  </Accordion>

  <Accordion title="Security">
    - Never commit AWS credentials to version control
    - Use IAM roles instead of access keys (EC2, ECS, Lambda)
    - Store secrets in AWS Secrets Manager or Systems Manager Parameter Store
    - Encrypt environment variables and secrets at rest
    - Use VPC for network isolation (ECS, EC2)
    - Implement least-privilege IAM policies
    - Enable CloudTrail for audit logging
    - Rotate credentials regularly
  </Accordion>

  <Accordion title="Monitoring and Logging">
    - Use CloudWatch for centralized logging
    - Enable Container Insights for ECS metrics
    - Set up CloudWatch alarms for errors and performance
    - Use AWS X-Ray for distributed tracing (optional)
    - Implement structured logging with JSON format
    - Set appropriate log retention periods
  </Accordion>

  <Accordion title="Infrastructure as Code">
    - Use AWS CDK or CloudFormation for reproducible deployments
    - Use AWS Copilot for simplified ECS deployments
    - Version control all infrastructure code
    - Separate environments (dev, staging, production)
    - Implement CI/CD pipelines with CodePipeline or GitHub Actions
  </Accordion>

  <Accordion title="High Availability">
    - Deploy across multiple Availability Zones
    - Use Application Load Balancer for ECS services (if exposing HTTP)
    - Implement health checks for all services
    - Use auto-scaling for fault tolerance
    - Set up CloudWatch alarms for critical issues
  </Accordion>

  <Accordion title="Performance">
    - Choose appropriate instance/task sizes for workload
    - Use provisioned concurrency for Lambda (reduce cold starts)
    - Enable Container Insights for ECS performance metrics
    - Use Amazon ElastiCache for caching (if needed)
    - Optimize Docker images for faster deployments
  </Accordion>
</Accordions>

## Next Steps

- Explore [Railway](/docs/guides/deployment/railway) for simpler managed deployment
- Review [Vercel](/docs/guides/deployment/vercel) for serverless API agents
- Learn about [Docker deployment](/docs/guides/deployment/docker) for self-hosted options
- Set up monitoring and alerting for your agents
- Implement CI/CD pipelines for automated deployments

## Sources

- [AWS Lambda Container Image Support](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html)
- [AWS Lambda Node.js Runtime](https://docs.aws.amazon.com/lambda/latest/dg/lambda-nodejs.html)
- [AWS ECS Fargate Documentation](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/AWS_Fargate.html)
- [AWS Copilot CLI](https://aws.github.io/copilot-cli/)
- [AWS CDK for TypeScript](https://docs.aws.amazon.com/cdk/v2/guide/work-with-cdk-typescript.html)
- [Deploying Node.js on AWS ECS Fargate](https://dev.to/aws-builders/deploying-nodejs-on-aws-ecs-fargate-1h8p)
- [AWS Lambda Execution Limits](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html)
