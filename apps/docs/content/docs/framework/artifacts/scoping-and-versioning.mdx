---
title: Scoping & Versioning
description: Session vs user namespaces and how artifact versions work
---

## Scoping

Artifacts can be scoped to the current session or to the user across sessions. Use the `user:` filename prefix to switch to user scope.

```typescript
import type { CallbackContext } from '@iqai/adk';

export async function saveScopedArtifacts(ctx: CallbackContext) {
  const text = (s: string) => ({
    inlineData: { data: Buffer.from(s).toString('base64'), mimeType: 'text/plain' }
  });

  // Session-scoped: available only in this session
  await ctx.saveArtifact('summary.txt', text('session summary'));

  // User-scoped: available across all sessions for this user
  await ctx.saveArtifact('user:settings.json', {
    inlineData: {
      data: Buffer.from(JSON.stringify({ theme: 'dark' })).toString('base64'),
      mimeType: 'application/json'
    }
  });
}
```

Loading works the same way â€” the prefix determines where the service looks:

```typescript
const latest = await ctx.loadArtifact('summary.txt'); // session scope
const userConfig = await ctx.loadArtifact('user:settings.json'); // user scope
```

## Versioning

Each save creates a new version starting at 0. Loading without a `version` parameter returns the latest.

```typescript
// v0
await ctx.saveArtifact('document.txt', {
  inlineData: { data: Buffer.from('A').toString('base64'), mimeType: 'text/plain' }
});

// v1
await ctx.saveArtifact('document.txt', {
  inlineData: { data: Buffer.from('B').toString('base64'), mimeType: 'text/plain' }
});

// Load specific version
const v0 = await ctx.loadArtifact('document.txt', 0);

// Load latest (v1)
const latestDoc = await ctx.loadArtifact('document.txt');
```

To list versions, call the underlying service (if you hold a reference). Contexts do not expose version listing.

```typescript
import { InMemoryArtifactService } from '@iqai/adk';

const artifactService = new InMemoryArtifactService();
// ... after saving some versions
const versions = await artifactService.listVersions({
  appName: 'my_app',
  userId: 'u1',
  sessionId: 's1',
  filename: 'document.txt'
});
// e.g., [0, 1, 2]
```

## Deletion

Deletion removes all versions of a filename in the current scope. The `deleteArtifact` method permanently removes the artifact and all its versions.

<Callout type="warning" title="Direct Service Access Required">
The `deleteArtifact` method is not available through `CallbackContext` or `ToolContext` for safety reasons. You must access it directly through the artifact service instance.
</Callout>

### Basic Deletion

```typescript
import { InMemoryArtifactService } from '@iqai/adk';

const artifactService = new InMemoryArtifactService();

// Delete an artifact (removes all versions)
await artifactService.deleteArtifact({
  appName: 'my_app',
  userId: 'u1',
  sessionId: 's1',
  filename: 'document.txt'
});
```

### Deletion Behavior

- **All Versions Removed**: Deletion removes all versions of the artifact, not just the latest
- **Scope-Aware**: Deletion respects the artifact's scope (session or user namespace)
- **Irreversible**: Once deleted, artifacts cannot be recovered (unless you have backups)
- **No Context Access**: Must be called directly on the artifact service, not through contexts

### Example: Cleanup After Processing

// Clean up temporary file using the service directly
// (Note: You'd need access to the artifact service instance)
await artifactService.deleteArtifact({
  appName: ctx.appName,
  userId: ctx.userId,
  sessionId: ctx.sessionId,
  filename: 'temp_analysis.csv'
});
```

For more comprehensive cleanup strategies, see [Best Practices](/docs/framework/artifacts/best-practices#artifact-cleanup-and-deletion).


