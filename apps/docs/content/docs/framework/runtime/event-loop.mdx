---
title: Event Loop
description: Understanding the cooperative async generator pattern and event flow
---

import { Callout } from 'fumadocs-ui/components/callout';

At the heart of the ADK Runtime is an Event Loop that facilitates communication between the Runner component and your execution logic (agents, tools, callbacks).

## Event-Driven Architecture

The Runtime operates on a cooperative async generator pattern where components communicate through events:

1. **Runner receives** user query and initiates agent processing
2. **Agent executes** logic until it has something to report (response, tool call, state change)
3. **Event yielded** by agent as part of async generator
4. **Runner processes** event, commits changes via services, forwards event upstream
5. **Agent resumes** execution after Runner completes event processing
6. **Cycle repeats** until agent has no more events for the current query

<Callout type="warn" title="Event Processing Order">
Agent execution pauses after yielding events until the Runner completes processing. This ensures state consistency and proper event ordering.
</Callout>

## Execution Flow

### Runner Role (Orchestrator)

The Runner acts as the central coordinator for a single user invocation. Its responsibilities in the loop are:

- **Initiation**: Receives the end user's query (new_message) and typically appends it to the session history via the SessionService.
- **Kick-off**: Starts the event generation process by calling the main agent's execution method (e.g., agent_to_run.run_async(...)).
- **Receive & Process**: Waits for the agent logic to yield or emit an Event. Upon receiving an event, the Runner promptly processes it. This involves:
  - Using configured Services (SessionService, ArtifactService, MemoryService) to commit changes indicated in event.actions (like state_delta, artifact_delta).
  - Performing other internal bookkeeping.
- **Yield Upstream**: Forwards the processed event onwards (e.g., to the calling application or UI for rendering).
- **Iterate**: Signals the agent logic that processing is complete for the yielded event, allowing it to resume and generate the next event.

### Execution Logic Role (Agent, Tool, Callback)

Your code within agents, tools, and callbacks is responsible for the actual computation and decision-making. Its interaction with the loop involves:

- **Execute**: Runs its logic based on the current InvocationContext, including the session state as it was when execution resumed.
- **Yield**: When the logic needs to communicate (send a message, call a tool, report a state change), it constructs an Event containing the relevant content and actions, and then yields this event back to the Runner.
- **Pause**: Crucially, execution of the agent logic pauses immediately after the yield statement. It waits for the Runner to complete step 3 (processing and committing).
- **Resume**: Only after the Runner has processed the yielded event does the agent logic resume execution from the statement immediately following the yield.
- **See Updated State**: Upon resumption, the agent logic can now reliably access the session state (ctx.session.state) reflecting the changes that were committed by the Runner from the previously yielded event.

## Event Flow Example

Here's how events flow through the system:

```typescript
import { LlmAgent, Runner, InMemorySessionService, Event } from '@iqai/adk';

async function demonstrateEventFlow() {
  const agent = new LlmAgent({
    name: "demo_agent",
    model: "gemini-2.5-flash",
    description: "Demonstrates event flow",
    instruction: "You are helpful and explain your thinking"
  });

  const sessionService = new InMemorySessionService();
  const session = await sessionService.createSession("demo", "user1");

  const runner = new Runner({
    appName: "demo",
    agent,
    sessionService
  });

  // Each iteration represents one event in the flow
  for await (const event of runner.runAsync({
    userId: "user1",
    sessionId: session.id,
    newMessage: { parts: [{ text: "What's 2+2?" }] }
  })) {
    console.log(`Event from ${event.author}:`, {
      content: event.content?.parts?.map(p => p.text).join(' '),
      hasActions: !!event.actions,
      isFinal: event.isFinalResponse()
    });
  }
}
```

## Event Types and Processing

### Content Events

Events containing user messages or agent responses:

```typescript
// User message event (generated by Runner)
const userEvent = new Event({
  invocationId: "inv_123",
  author: "user",
  content: {
    parts: [{ text: "Hello, how are you?" }]
  }
});

// Agent response event (generated by Agent)
const agentEvent = new Event({
  invocationId: "inv_123",
  author: "my_agent",
  content: {
    parts: [{ text: "I'm doing well, thank you!" }]
  }
});
```

### Function Call Events

Events requesting tool execution:

```typescript
// Function call event
const functionCallEvent = new Event({
  invocationId: "inv_123",
  author: "my_agent",
  content: {
    parts: [{
      functionCall: {
        name: "search_web",
        args: { query: "latest AI news" }
      }
    }]
  }
});

// Function response event
const functionResponseEvent = new Event({
  invocationId: "inv_123",
  author: "my_agent",
  content: {
    parts: [{
      functionResponse: {
        name: "search_web",
        response: { results: [...] }
      }
    }]
  }
});
```

### State Change Events

Events that modify session state:

```typescript
import { EventActions, Event } from '@iqai/adk';

const stateChangeEvent = new Event({
  invocationId: "inv_123",
  author: "my_agent",
  actions: new EventActions({
    stateDelta: {
      "user_preference": "dark_mode",
      "session_count": 5
    }
  })
});
```

## Async Generator Pattern

### Agent Implementation

Agents implement the async generator pattern in their `runAsyncImpl` method:

```typescript
import { BaseAgent, InvocationContext, Event } from '@iqai/adk';

class CustomAgent extends BaseAgent {
  protected async *runAsyncImpl(
    ctx: InvocationContext
  ): AsyncGenerator<Event, void, unknown> {

    // Step 1: Analyze user input
    yield new Event({
      invocationId: ctx.invocationId,
      author: this.name,
      content: { parts: [{ text: "Let me think about this..." }] }
    });

    // Step 2: Perform some computation
    const result = await this.processUserQuery(ctx.userContent);

    // Step 3: Yield final response
    yield new Event({
      invocationId: ctx.invocationId,
      author: this.name,
      content: { parts: [{ text: result }] }
    });
  }
}
```

### Runner Processing

The Runner processes each yielded event:

```typescript
// Simplified Runner event processing
for await (const event of agent.runAsync(invocationContext)) {
  // 1. Validate event
  if (!event.partial) {
    // 2. Persist to session
    await this.sessionService.appendEvent(session, event);

    // 3. Apply state changes
    if (event.actions?.stateDelta) {
      // Apply state changes through service
    }

    // 4. Handle artifacts
    if (event.actions?.artifactDelta) {
      // Process artifact changes
    }
  }

  // 5. Forward upstream
  yield event;
}
```

## Event Processing Guarantees

### Ordering Guarantees

- Events are processed in the order they are yielded
- State changes are applied atomically per event
- No race conditions between event processing

### State Consistency

- Agent execution pauses until Runner processes events
- State changes are committed before agent resumes
- Rollback support for failed operations

### Error Handling

- Exceptions in event processing are propagated to agents
- Partial state changes are rolled back on failure
- Graceful degradation for service failures

## Streaming and Partial Events

### Partial Events

For real-time user experience, agents can yield partial events:

```typescript
// Streaming response
yield new Event({
  invocationId: ctx.invocationId,
  author: this.name,
  content: { parts: [{ text: "Thinking" }] },
  partial: true  // Not persisted to session
});

yield new Event({
  invocationId: ctx.invocationId,
  author: this.name,
  content: { parts: [{ text: "Thinking..." }] },
  partial: true
});

// Final response
yield new Event({
  invocationId: ctx.invocationId,
  author: this.name,
  content: { parts: [{ text: "Here's my complete response" }] },
  partial: false  // Persisted to session
});
```

### Live Mode

For real-time interactions, the Runtime supports live mode:

```typescript
// Live mode processing (voice/video)
for await (const event of agent.runLive?.(invocationContext) ||
                          agent.runAsync(invocationContext)) {
  // Handle real-time events
  if (event.content) {
    sendToUserInterface(event);
  }
}
```
