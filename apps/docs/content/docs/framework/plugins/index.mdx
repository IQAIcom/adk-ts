---
title: Plugins
description: Introduction to `@iq/adk` plugins
---

import { Cards, Card } from "fumadocs-ui/components/card";
import { Callout } from "fumadocs-ui/components/callout";

A Plugin in Agent Development Kit (ADK) is a custom code module that can be executed at various stages of an agent workflow lifecycle using callback hooks. You use Plugins for functionality that is applicable across your agent workflow. Some typical applications of Plugins are as follows:

- Logging and tracing: Create detailed logs of agent, tool, and generative AI model activity for debugging and performance analysis.

- Policy enforcement: Implement security guardrails, such as a function that checks if users are authorized to use a specific tool and prevent its execution if they do not have permission.

- Monitoring and metrics: Collect and export metrics on token usage, execution times, and invocation counts to monitoring systems such as [Langfuse](https://langfuse.com/docs).

- Response caching: Check if a request has been made before, so you can return a cached response, skipping expensive or time consuming AI model or tool calls.

- Request or response modification: Dynamically add information to AI model prompts or standardize tool output responses.

<Callout type="warning" title="Caution">
  Plugins are not supported by the [ADK web interface](/docs/framework/get-started/quickstart#web-based-interface-adk-web).
  If your ADK workflow uses Plugins, you must run your workflow without the web interface.
</Callout>

## How do Plugins work?

An ADK Plugin extends the `BasePlugin` class and contains one or more callback methods, indicating where in the agent lifecycle the Plugin should be executed. You integrate Plugins into an agent by registering them in your agent's Runner class. For more information on how and where you can trigger Plugins in your agent application, see Plugin callback hooks.

Plugin functionality builds on [Callbacks](/docs/framework/callbacks), which is a key design element of the ADK's extensible architecture. While a typical Agent Callback is configured on a single agent, a single tool for a specific task, a Plugin is registered once on the `Runner` and its callbacks apply globally to every agent, tool, and LLM call managed by that runner. Plugins let you package related callback functions together to be used across a workflow. This makes Plugins an ideal solution for implementing features that cut across your entire agent application.

## Prebuilt Plugins

ADK includes several plugins that you can add to your agent workflows immediately:

- [Reflect and Retry Tools](plugins/reflect-and-retry): Automatically tracks tool execution failures and implements intelligent retry logic with guided feedback to help agents recover from errors and successfully complete tool operations.
- [Langfuse Plugin](plugins/langfuse-plugin): Provides comprehensive observability and tracing for your agent workflows by integrating with Langfuse, enabling you to monitor user interactions, agent decisions, model calls, and tool executions with detailed performance metrics and debugging insights.

## Define and register Plugins

This section explains how to define Plugin classes and register them as part of your agent workflow. For a complete code example, see Plugin Basic in the repository.

### Create Plugin class

A Plugin is a stateful module that extends `BasePlugin` and implements one or more lifecycle hooks. Hooks can observe (return `undefined`), intervene (return a value to short-circuit), or amend context. The example below shows a practical Plugin that logs key moments and demonstrates the three hook styles.

```typescript
import {
  BasePlugin,
  Agents,
  Events,
  Models,
  Tools,
} from "adk";
import type { Content } from "@google/genai";

// A simple plugin that logs user messages, agent/model/tool activity, and cleans up on close.
export class BasicLoggingPlugin extends BasePlugin {
  constructor(name = "basic_logging_plugin") {
    super(name);
  }

  // Observe: log user messages when they enter the session
  async onUserMessageCallback(params: {
    invocationContext: Agents.InvocationContext;
    userMessage: Content;
  }): Promise<Content | undefined> {
    const text = params.userMessage?.parts?.map((p) => p.text || "").join("") || "";
    console.log(`[Plugin:${this.name}] user_message: ${text.slice(0, 200)}`);
    return undefined;
  }

  // Observe: before the runner starts executing any agent
  async beforeRunCallback(params: {
    invocationContext: Agents.InvocationContext;
  }): Promise<Events.Event | undefined> {
    console.log(`[Plugin:${this.name}] run_start: ${params.invocationContext.invocationId}`);
    return undefined;
  }

  // Observe: each event emitted by the agent tree
  async onEventCallback(params: {
    invocationContext: Agents.InvocationContext;
    event: Events.Event;
  }): Promise<Events.Event | undefined> {
    if (params.event.partial) return undefined;
    const preview =
      params.event.content?.parts?.map((p) => p.text || "").join("").slice(0, 120) || "";
    console.log(
      `[Plugin:${this.name}] on_event author=${params.event.author} final=${params.event.isFinalResponse()} preview="${preview}"`
    );
    return undefined;
  }

  // Observe: after the run completes (cleanup, flush, aggregate metrics)
  async afterRunCallback(_params: {
    invocationContext: Agents.InvocationContext;
    result?: any;
  }): Promise<void> {
    console.log(`[Plugin:${this.name}] run_complete`);
  }

  // Observe: agent-level lifecycle (runs before agent logic)
  async beforeAgentCallback(params: {
    agent: Agents.BaseAgent;
    callbackContext: Agents.CallbackContext;
  }): Promise<Content | undefined> {
    console.log(
      `[Plugin:${this.name}] agent_start ${params.agent.name} branch=${params.callbackContext.invocationContext.branch}`
    );
    return undefined;
  }

  // Observe: agent-level lifecycle (runs after agent logic)
  async afterAgentCallback(params: {
    agent: Agents.BaseAgent;
    callbackContext: Agents.CallbackContext;
    result?: any;
  }): Promise<Content | undefined> {
    console.log(`[Plugin:${this.name}] agent_complete ${params.agent.name}`);
    return undefined;
  }

  // Intervene or Amend: before model call (can return a cached LlmResponse to short-circuit)
  async beforeModelCallback(_params: {
    callbackContext: Agents.CallbackContext;
    llmRequest: Models.LlmRequest;
  }): Promise<Models.LlmResponse | undefined> {
    // Example: return undefined to allow normal execution
    return undefined;
  }

  // Amend or Observe: after model call (can modify the response or just log it)
  async afterModelCallback(params: {
    callbackContext: Agents.CallbackContext;
    llmResponse: Models.LlmResponse;
    llmRequest?: Models.LlmRequest;
  }): Promise<Models.LlmResponse | undefined> {
    console.log(
      `[Plugin:${this.name}] llm_response model=${params.llmRequest?.model} finish=${params.llmResponse.finishReason}`
    );
    return undefined;
  }

  // Observe or Intervene: before tool call (can return a result to skip the tool)
  async beforeToolCallback(params: {
    tool: Tools.BaseTool;
    toolArgs: Record<string, any>;
    toolContext: Tools.ToolContext;
  }): Promise<Record<string, any> | undefined> {
    console.log(
      `[Plugin:${this.name}] before_tool ${params.tool.name} args=${JSON.stringify(params.toolArgs).slice(0, 120)}`
    );
    return undefined;
  }

  // Amend or Observe: after tool call (can modify/override tool result)
  async afterToolCallback(params: {
    tool: Tools.BaseTool;
    toolArgs: Record<string, any>;
    toolContext: Tools.ToolContext;
    result: Record<string, any>;
  }): Promise<Record<string, any> | undefined> {
    console.log(
      `[Plugin:${this.name}] after_tool ${params.tool.name} result_preview=${JSON.stringify(params.result).slice(0, 120)}`
    );
    return undefined;
  }

  // Observe: tool error handling (log, attach metadata, or provide recovery output)
  async onToolErrorCallback(params: {
    tool: Tools.BaseTool;
    toolArgs: Record<string, any>;
    toolContext: Tools.ToolContext;
    error: unknown;
  }): Promise<Record<string, any> | undefined> {
    const message = params.error instanceof Error ? params.error.message : String(params.error);
    console.warn(`[Plugin:${this.name}] tool_error ${params.tool.name}: ${message}`);
    return undefined;
  }

  // Observe: model error handling
  async onModelErrorCallback(params: {
    callbackContext: Agents.CallbackContext;
    llmRequest: Models.LlmRequest;
    error: unknown;
  }): Promise<Models.LlmResponse | undefined> {
    const message = params.error instanceof Error ? params.error.message : String(params.error);
    console.warn(`[Plugin:${this.name}] llm_error model=${params.llmRequest.model}: ${message}`);
    return undefined;
  }

  // Cleanup resources (e.g., flush telemetry clients)
  async close(): Promise<void> {
    console.log(`[Plugin:${this.name}] close`);
  }
}
```

### Register Plugin class

Register Plugins on the `Runner`. Runner-level Plugins apply globally to all Agents, Tools, and LLM calls managed by that runner. You can set a `pluginCloseTimeout` to bound shutdown time.

```typescript
import { InMemoryRunner, Agents } from "adk";
import { BasicLoggingPlugin } from "./basic-logging-plugin";

// Build a root agent (can be any BaseAgent; LlmAgent shown later)
const rootAgent = new Agents.BaseAgent({
  name: "root",
  description: "Root agent",
});

// Pass initialization options to your plugin constructor if needed
const logging = new BasicLoggingPlugin("basic_logging_plugin");

// Register plugins at Runner construction
const runner = new InMemoryRunner(rootAgent, {
  appName: "DocsExampleApp",
  plugins: [logging],
});

// Optionally control close timeout at Runner level (constructor overload)
// new Runner({ appName, agent, sessionService, plugins: [logging], pluginCloseTimeout: 5000 });
```

### Run the agent with the Plugin

The following example shows a complete workflow using `LlmAgent`, a simple `FunctionTool`, and a plugin attached via `InMemoryRunner`. It streams events and demonstrates error handling.

```typescript
import {
  LlmAgent,
  InMemoryRunner,
  Tools,
  Events,
  Models,
} from "adk";
import { BasicLoggingPlugin } from "./basic-logging-plugin";

// A toy tool to demonstrate tool callbacks
class EchoTool extends Tools.BaseTool {
  constructor() {
    super({
      name: "echo",
      description: "Echo back a provided message",
    });
  }
  async runAsync(args: Record<string, any>): Promise<any> {
    if (!args?.message) {
      throw new Error("message is required");
    }
    return { echoed: String(args.message) };
  }
}

// Build a simple agent
const agent = new LlmAgent({
  name: "assistant",
  description: "Answers questions and can echo messages",
  model: "gemini-1.5-flash",
  instruction: "Be concise and helpful.",
  tools: [new EchoTool()],
});

// Attach plugin via a Runner
const runner = new InMemoryRunner(agent, {
  appName: "DocsExampleApp",
  plugins: [new BasicLoggingPlugin()],
});

// Run and stream events
async function runExample() {
  try {
    const message = {
      role: "user",
      parts: [{ text: "Say hello and call echo with message='Hello!'" }],
    };
    for await (const event of runner.runAsync({
      userId: "demo-user",
      sessionId: "demo-session",
      newMessage: message,
    })) {
      // Final responses contain completed content
      if (event.isFinalResponse()) {
        const text =
          event.content?.parts?.map((p) => p.text || "").join("") || "";
        console.log(`[Final] ${text}`);
      }
      // Function responses include tool outputs
      if (event.getFunctionResponses().length > 0) {
        console.log(`[ToolResponse]`, event.getFunctionResponses()[0]?.response);
      }
    }
  } catch (error) {
    // Errors thrown by plugins or runtime will surface here
    console.error("Run failed:", error);
  } finally {
    // Ensure plugins can flush/cleanup
    await runner.close();
  }
}

runExample();
```

## Build workflows with Plugins

Plugin callback hooks are a mechanism for implementing logic that intercepts, modifies, and even controls the agent's execution lifecycle. Each hook is a specific method in your Plugin class that you can implement to run code at a key moment. You have a choice between two modes of operation based on your hook's return value:

- To Observe: Implement a hook with no return value (`undefined`). This approach is for tasks such as logging or collecting metrics, as it allows the agent's workflow to proceed to the next step without interruption. For example, you could use `afterToolCallback` in a Plugin to log every tool's result for debugging.

- To Intervene: Implement a hook and return a value. This approach short-circuits the workflow. The `Runner` halts processing, skips any subsequent plugins and the original intended action, like a Model call, and use a Plugin callback's return value as the result. A common use case is implementing `beforeModelCallback` to return a cached `LlmResponse`, preventing a redundant and costly API call.

- To Amend: Implement a hook and modify the Context object. This approach allows you to modify the context data for the module to be executed without otherwise interrupting the execution of that module. For example, adding additional, standardized prompt text for Model object execution.

**Caution**: Plugin callback functions have precedence over callbacks implemented at the object level. This behavior means that Any Plugin callbacks code is executed before any Agent, Model, or Tool objects callbacks are executed. Furthermore, if a Plugin-level agent callback returns any value, and not an empty (`undefined`) response, the Agent, Model, or Tool-level callback is not executed (skipped).

The Plugin design establishes a hierarchy of code execution and separates global concerns from local agent logic. A Plugin is the stateful module you build, such as `PerformanceMonitoringPlugin`, while the callback hooks are the specific functions within that module that get executed. This architecture differs fundamentally from standard Agent Callbacks in these critical ways:

- **Scope**: Plugin hooks are global. You register a Plugin once on the `Runner`, and its hooks apply universally to every Agent, Model, and Tool it manages. In contrast, Agent Callbacks are local, configured individually on a specific agent instance.

- **Execution Order**: Plugins have precedence. For any given event, the Plugin hooks always run before any corresponding Agent Callback. This system behavior makes Plugins the correct architectural choice for implementing cross-cutting features like security policies, universal caching, and consistent logging across your entire application.

### Agent Callbacks and Plugins

<table>
  <thead>
    <tr>
      <th></th>
      <th><strong>Plugins</strong></th>
      <th><strong>Agent Callbacks</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Scope</strong></td>
      <td><strong>Global</strong>: Apply to all agents/tools/LLMs in the
<code>Runner</code>.</td>
      <td><strong>Local</strong>: Apply only to the specific agent instance
they are configured on.</td>
    </tr>
    <tr>
      <td><strong>Primary Use Case</strong></td>
      <td><strong>Horizontal Features</strong>: Logging, policy, monitoring,
global caching.</td>
      <td><strong>Specific Agent Logic</strong>: Modifying the behavior or
state of a single agent.</td>
    </tr>
    <tr>
      <td><strong>Configuration</strong></td>
      <td>Configure once on the <code>Runner</code>.</td>
      <td>Configure individually on each <code>BaseAgent</code> instance.</td>
    </tr>
    <tr>
      <td><strong>Execution Order</strong></td>
      <td>Plugin callbacks run <strong>before</strong> Agent Callbacks.</td>
      <td>Agent callbacks run <strong>after</strong> Plugin callbacks.</td>
    </tr>
  </tbody>
</table>

## Plugin callback hooks

You define when a Plugin is called with the callback functions to define in your Plugin class. Callbacks are available when a user message is received, before and after an `Runner`, `Agent`, `Model`, or `Tool` is called, for `Events`, and when a `Model`, or `Tool` error occurs. These callbacks include, and take precedence over, the any callbacks defined within your Agent, Model, and Tool classes.

The following diagram illustrates callback points where you can attach and run Plugin functionality during your agents workflow:

<Mermaid
chart="sequenceDiagram
    participant U as User
    participant R as Runner
    participant PM as PluginManager
    participant A as Agent
    participant L as LLM
    participant T as Tool

    U->>R: newMessage
    R->>PM: onUserMessageCallback
    PM-->>R: observe/modify user message

    R->>PM: beforeRunCallback
    PM-->>R: optional early exit Event
    alt Early Exit
        PM-->>R: Event yielded run halts
    else Continue
        R->>A: runAsync
        A->>PM: beforeAgentCallback
        PM-->>A: optional early exit Content
        A->>L: Model Request
        PM->>L: beforeModelCallback
        L-->>A: LlmResponse
        PM->>A: afterModelCallback
        A->>A: Emit Events
        R->>PM: onEventCallback
        PM-->>R: observe/modify Event
        A->>T: Tool Call
        PM->>T: beforeToolCallback
        T-->>A: Tool Result
        PM->>T: afterToolCallback
        Note over PM,T: onToolErrorCallback on failures
        Note over PM,L: onModelErrorCallback on failures
        A->>PM: afterAgentCallback
        PM-->>A: optional Content
    end
    R->>PM: afterRunCallback
    PM-->>R: cleanup metrics"
/>

### Reference Implementation

- Reflect and Retry Tools: robust tool failure tracking and guided retries. See [reflect-retry-tool-plugin.ts](file:///Users/lope/Desktop/open-source/adk-ts/packages/adk/src/plugins/reflect-retry-tool-plugin.ts).
- Langfuse Plugin: end-to-end tracing across user, agent, model, and tool spans. See [langfuse-plugin.ts](file:///Users/lope/Desktop/open-source/adk-ts/packages/adk/src/plugins/langfuse-plugin.ts).
- Base Plugin API: hook signatures and defaults. See [base-plugin.ts](file:///Users/lope/Desktop/open-source/adk-ts/packages/adk/src/plugins/base-plugin.ts) and [plugin-manager.ts](file:///Users/lope/Desktop/open-source/adk-ts/packages/adk/src/plugins/plugin-manager.ts).
