---
title: MCP Tools
description: Model Context Protocol tools for standardized integrations
---

import { Cards, Card } from "fumadocs-ui/components/card";
import { Callout } from "fumadocs-ui/components/callout";

Model Context Protocol (MCP) is an open standard for connecting LLMs with external systems, data sources, and services through standardized interfaces. ADK-TS lets you consume MCP servers in your agents, access tools from IQ AI's blockchain and AI services, or expose your own ADK-TS tools as MCP servers.

## Quick Start

The fastest way to start using MCP tools is with wrapper functions for IQ AI's MCP servers:

```typescript
import { McpAtp, LlmAgent } from "@iqai/adk";

// Initialize ATP MCP toolset
const atpToolset = McpAtp({
  env: {
    ATP_WALLET_PRIVATE_KEY: process.env.WALLET_PRIVATE_KEY,
    ATP_API_KEY: process.env.ATP_API_KEY,
  },
});

// Get ATP tools
const tools = await atpToolset.getTools();

// Create agent with MCP tools
const agent = new LlmAgent({
  name: "blockchain_agent",
  model: "gemini-2.5-flash",
  instruction:
    "You can query blockchain data and interact with DeFi protocols.",
  tools,
});

// Use the agent
const result = await agent.ask("Get token statistics for contract 0x123...");

// Clean up when done
await atpToolset.close();
```

## Integration Approaches

<Cards>
  <Card
    title="🔌 Wrapper Functions"
    description="Use IQAI MCP servers with simple configuration"
  />

<Card
  title="🛠️ McpToolset"
  description="Connect to any MCP server with full control"
/>

  <Card
    title="🤖 ADK-TS as MCP Server"
    description="Expose ADK-TS tools via MCP protocol"
  />
</Cards>

## Using Wrapper Functions

For IQ AI MCP servers, wrapper functions provide simple configuration without verbose setup. These are pre-built adapters that handle all connection and configuration details, letting you focus on agent logic.

### Available IQ AI MCP Wrappers

IQ AI provides 14+ specialized MCP servers covering blockchain, DeFi, and AI operations:

| Wrapper             | Purpose                                                                 | Required Env Vars                       | Module                 |
| ------------------- | ----------------------------------------------------------------------- | --------------------------------------- | ---------------------- |
| `McpAtp()`          | AI Agent Tokenization Platform - token stats, agent metrics, tokenomics | `ATP_WALLET_PRIVATE_KEY`, `ATP_API_KEY` | @iqai/mcp-atp          |
| `McpAbi()`          | Smart contract ABI interactions for Ethereum-compatible blockchains     | `CONTRACT_ABI`, `CONTRACT_ADDRESS`      | @iqai/mcp-abi          |
| `McpBamm()`         | Borrow Automated Market Maker operations on Fraxtal                     | `WALLET_PRIVATE_KEY`                    | @iqai/mcp-bamm         |
| `McpFraxlend()`     | Fraxlend lending platform interactions                                  | `WALLET_PRIVATE_KEY`                    | @iqai/mcp-fraxlend     |
| `McpIqWiki()`       | IQ.wiki data access and user activity management                        | None                                    | @iqai/mcp-iqwiki       |
| `McpNearAgent()`    | NEAR blockchain with AI-driven event processing                         | `ACCOUNT_ID`, `ACCOUNT_KEY`             | @iqai/mcp-near-agent   |
| `McpNearIntents()`  | NEAR Protocol intent swaps functionality                                | `ACCOUNT_ID`, `ACCOUNT_KEY`             | @iqai/mcp-near-intents |
| `McpOdos()`         | DEX aggregation through ODOS protocol                                   | `WALLET_PRIVATE_KEY`                    | @iqai/mcp-odos         |
| `McpTelegram()`     | Telegram bot and channel interactions                                   | `TELEGRAM_BOT_TOKEN`                    | @iqai/mcp-telegram     |
| `McpDiscord()`      | Discord bot and server management                                       | `DISCORD_TOKEN`                         | @iqai/mcp-discord      |
| `McpUpbit()`        | Upbit cryptocurrency exchange integration                               | `UPBIT_ACCESS_KEY`, `UPBIT_SECRET_KEY`  | @iqai/mcp-upbit        |
| `McpCoinGecko()`    | Free crypto market data (public endpoint)                               | None                                    | Remote SSE             |
| `McpCoinGeckoPro()` | Premium crypto market data with higher limits                           | `COINGECKO_PRO_API_KEY`                 | Remote SSE             |

### Third-Party MCP Servers

| Wrapper           | Purpose                                  | Module                                  |
| ----------------- | ---------------------------------------- | --------------------------------------- |
| `McpFilesystem()` | File system operations (read/write/list) | @modelcontextprotocol/server-filesystem |
| `McpMemory()`     | Memory and note-taking capabilities      | @modelcontextprotocol/server-memory     |
| `McpGeneric()`    | Any npm-published MCP server             | Custom package                          |

### Wrapper Configuration Example

```typescript
import { McpAtp, McpNearAgent, McpCoinGecko, LlmAgent } from "@iqai/adk";

// IQ AI wrapper with blockchain credentials
const atpToolset = McpAtp({
  env: {
    ATP_WALLET_PRIVATE_KEY: process.env.WALLET_PRIVATE_KEY,
    ATP_API_KEY: process.env.ATP_API_KEY,
  },
  debug: true,
  retryOptions: {
    maxRetries: 3,
    initialDelay: 200,
  },
});

// NEAR blockchain wrapper
const nearToolset = McpNearAgent({
  env: {
    ACCOUNT_ID: process.env.NEAR_ACCOUNT_ID,
    ACCOUNT_KEY: process.env.NEAR_ACCOUNT_KEY,
    NEAR_NETWORK_ID: "testnet",
  },
});

// Free crypto data - no auth needed
const cryptoToolset = McpCoinGecko();

// Get all tools
const [atpTools, nearTools, cryptoTools] = await Promise.all([
  atpToolset.getTools(),
  nearToolset.getTools(),
  cryptoToolset.getTools(),
]);

// Create agent with multiple wrapper tools
const agent = new LlmAgent({
  name: "defi_assistant",
  model: "gemini-2.5-flash",
  instruction: `You have access to multiple blockchain and market data sources:
               - ATP tools for agent tokenomics and statistics
               - NEAR Protocol tools for blockchain operations
               - CoinGecko for real-time crypto market data
               Use these tools to provide comprehensive DeFi insights.`,
  tools: [...atpTools, ...nearTools, ...cryptoTools],
});

// Use the agent
const result = await agent.ask(
  "What's the current ATP token price and NEAR protocol stats?"
);

// Clean up when done
await Promise.all([
  atpToolset.close(),
  nearToolset.close(),
  cryptoToolset.close(),
]);
```

## Using McpToolset for Custom Servers

When you need to connect to MCP servers not covered by wrapper functions (community servers, custom servers, or remote endpoints), use the `McpToolset` class directly. This gives you full control over connection configuration, tool discovery, and filtering.

### How McpToolset Works

McpToolset is the core integration layer that:

1. **Establishes Connection**: Connects to your MCP server via stdio (local process) or SSE (remote HTTP)
2. **Discovers Tools**: Queries the server for available tools and their schemas
3. **Adapts Schemas**: Converts MCP tool definitions to ADK-compatible `BaseTool` instances
4. **Proxies Calls**: Forwards your agent's tool calls to the MCP server and returns responses
5. **Manages Lifecycle**: Handles graceful connection shutdown and resource cleanup

### Connection Types

McpToolset supports two connection modes:

| Mode      | Use Case                               | Configuration                     |
| --------- | -------------------------------------- | --------------------------------- |
| **Stdio** | Local MCP servers running as processes | `mode: "stdio"` with command/args |
| **SSE**   | Remote MCP servers over HTTP           | `mode: "sse"` with serverUrl      |

### McpConfig Parameters

| Parameter                   | Type             | Required | Description                                      |
| --------------------------- | ---------------- | -------- | ------------------------------------------------ |
| `name`                      | string           | Yes      | Display name for the MCP client                  |
| `description`               | string           | Yes      | Description of the client's purpose              |
| `transport`                 | McpTransportType | Yes      | Connection configuration (stdio or SSE)          |
| `timeout`                   | number           | No       | Request timeout in milliseconds (default: 30000) |
| `retryOptions.maxRetries`   | number           | No       | Max retry attempts (default: 3)                  |
| `retryOptions.initialDelay` | number           | No       | Initial retry delay in ms (default: 200)         |
| `retryOptions.maxDelay`     | number           | No       | Maximum delay between retries in ms              |
| `cacheConfig.enabled`       | boolean          | No       | Cache tool definitions (default: true)           |
| `cacheConfig.maxAge`        | number           | No       | Max cache age in milliseconds                    |
| `cacheConfig.maxSize`       | number           | No       | Max number of tools to cache                     |
| `debug`                     | boolean          | No       | Enable debug logging                             |
| `samplingHandler`           | SamplingHandler  | No       | Handle MCP sampling requests                     |

### Stdio Connection Example (Local MCP Server)

Connect to file system operations locally:

```typescript
import { McpToolset, LlmAgent, type McpConfig } from "@iqai/adk";

// Configure for local filesystem MCP server
const mcpConfig: McpConfig = {
  name: "Filesystem MCP",
  description: "Local file system operations",
  debug: true,
  timeout: 5000,
  retryOptions: {
    maxRetries: 3,
    initialDelay: 200,
  },
  transport: {
    mode: "stdio",
    command: "npx",
    args: [
      "-y",
      "@modelcontextprotocol/server-filesystem",
      "/home/user/documents", // Absolute path to allowed folder
    ],
    env: {
      PATH: process.env.PATH || "",
      DEBUG: "1", // Enable MCP server debug logging
    },
  },
};

// Initialize toolset
const toolset = new McpToolset(mcpConfig);
const tools = await toolset.getTools();

console.log(`Discovered ${tools.length} tools from filesystem server`);
tools.forEach((tool) => console.log(`  - ${tool.name}: ${tool.description}`));

// Create agent with filesystem tools
const agent = new LlmAgent({
  name: "file_agent",
  model: "gemini-2.5-flash",
  instruction: `You can manage files in the documents folder. Available operations:
               - Read and write text files
               - List directory contents
               - Search for specific files
               
               Always ask the user before modifying files.`,
  tools,
});

// Use the agent
const result = await agent.ask(
  "List all TypeScript files in the src directory"
);

// Always cleanup
await toolset.close();
```

### SSE Connection Example (Remote MCP Server)

Connect to a remote MCP server via HTTP:

```typescript
import { McpToolset, LlmAgent, type McpConfig } from "@iqai/adk";

const remoteConfig: McpConfig = {
  name: "Remote Research Server",
  description: "Remote MCP server with research tools",
  timeout: 10000,
  retryOptions: {
    maxRetries: 5,
    initialDelay: 500,
  },
  transport: {
    mode: "sse",
    serverUrl: "https://mcp-research-api.example.com/v1/mcp",
    headers: {
      Authorization: `Bearer ${process.env.MCP_AUTH_TOKEN}`,
      "User-Agent": "ADK-MCP-Client/1.0",
    },
  },
};

const toolset = new McpToolset(remoteConfig);
const tools = await toolset.getTools();

const agent = new LlmAgent({
  name: "research_agent",
  model: "gemini-2.5-flash",
  tools,
});

const result = await agent.ask(
  "Search for the latest research papers on AI safety"
);
await toolset.close();
```

### Advanced Example: Multiple Stdio Servers

Combine tools from multiple local MCP servers:

```typescript
import { McpToolset, LlmAgent } from "@iqai/adk";

// Server 1: Filesystem operations
const fsToolset = new McpToolset({
  name: "Filesystem",
  description: "File operations",
  transport: {
    mode: "stdio",
    command: "npx",
    args: ["-y", "@modelcontextprotocol/server-filesystem", "/data"],
    env: { PATH: process.env.PATH || "" },
  },
  retryOptions: { maxRetries: 2, initialDelay: 200 },
});

// Server 2: Git operations
const gitToolset = new McpToolset({
  name: "Git",
  description: "Git repository operations",
  transport: {
    mode: "stdio",
    command: "npx",
    args: ["-y", "@modelcontextprotocol/server-git", "/repo"],
    env: { PATH: process.env.PATH || "" },
  },
  retryOptions: { maxRetries: 2, initialDelay: 200 },
});

try {
  // Get tools from both servers
  const [fsTools, gitTools] = await Promise.all([
    fsToolset.getTools(),
    gitToolset.getTools(),
  ]);

  // Create agent with combined tools
  const agent = new LlmAgent({
    name: "repo_manager",
    model: "gemini-2.5-flash",
    instruction: `You can manage both files and git repositories.
                 Use filesystem tools to read/write files.
                 Use git tools to version control changes.`,
    tools: [...fsTools, ...gitTools],
  });

  const result = await agent.ask(
    "Read the main README file and create a git commit"
  );
} finally {
  // Always cleanup both connections
  await Promise.all([fsToolset.close(), gitToolset.close()]);
}
```

## McpToolset vs Wrapper Functions

**Why choose one over the other?**

Wrapper functions abstract away boilerplate configuration, making code cleaner and shorter. McpToolset gives you direct control over every connection detail. Here's when to use each:

**Use Wrapper Functions when:**

- Connecting to IQ AI's pre-built blockchain/AI services (ATP, NEAR, Fraxlend, etc.)
- You want automatic credential handling and connection management
- Configuration is simple (mostly environment variables)
- You need production-tested, optimized integrations

**Use McpToolset when:**

- Connecting to community MCP servers not in the wrapper list
- You need fine-grained control over connection parameters (timeouts, retries, caching)
- Building custom tool filtering or schema adaptation
- Working with remote MCP endpoints requiring custom headers
- Creating your own MCP server integrations

**Comparison Example:**

```typescript
// ❌ McpToolset - Verbose for IQ AI servers (unnecessary complexity)
const mcpConfig: McpConfig = {
  name: "ATP MCP Client",
  description: "AI Agent Tokenization Platform",
  timeout: 30000,
  retryOptions: { maxRetries: 2, initialDelay: 200 },
  cacheConfig: { enabled: true },
  transport: {
    mode: "stdio",
    command: "npx",
    args: ["-y", "@iqai/mcp-atp"],
    env: {
      ATP_WALLET_PRIVATE_KEY: process.env.WALLET_PRIVATE_KEY,
      ATP_API_KEY: process.env.ATP_API_KEY,
      PATH: process.env.PATH,
    },
  },
};
const toolset = new McpToolset(mcpConfig); // 15 lines!

// ✅ Wrapper Function - Clean and simple
const toolset = McpAtp({
  env: {
    ATP_WALLET_PRIVATE_KEY: process.env.WALLET_PRIVATE_KEY,
    ATP_API_KEY: process.env.ATP_API_KEY,
  },
}); // 7 lines!
```

## Connection Types Overview

Both wrapper functions and McpToolset use these connection types:

### Stdio Transport (Local Processes)

Perfect for:

- Development and testing
- Local MCP servers in the same environment
- Tools bundled as npm/Python packages

Example community servers:

- `@modelcontextprotocol/server-filesystem` - File operations
- `@modelcontextprotocol/server-memory` - Memory/notes
- `@modelcontextprotocol/server-postgres` - Database queries

```typescript
transport: {
  mode: "stdio",
  command: "npx",
  args: ["-y", "@modelcontextprotocol/server-filesystem", "/allowed/path"],
  env: {
    PATH: process.env.PATH || "",
    // Additional env vars your server needs
  },
}
```

### SSE Transport (Remote Servers)

Perfect for:

- Production deployments
- Remote MCP services
- Load-balanced or cloud-hosted servers

Example remote servers:

- CoinGecko MCP API: `https://mcp.api.coingecko.com/mcp`
- Custom API endpoints with SSE support

```typescript
transport: {
  mode: "sse",
  serverUrl: "https://api.example.com/mcp",
  headers: {
    "Authorization": `Bearer ${process.env.MCP_TOKEN}`,
    "X-Client-ID": "adk-agent",
  },
}
```

## ADK-TS as MCP Server

Transform your ADK-TS tools into MCP-compatible services that other applications and clients can consume. This enables you to share agent capabilities across your organization and integrate with MCP-supporting tools and platforms.

### Why Expose ADK-TS as MCP?

- **Interoperability**: Make your ADK-TS tools available to any MCP client (not just ADK-TS agents)
- **Code Reuse**: Share the same tool implementations across different applications
- **Ecosystem Integration**: Connect with other tools and platforms using the MCP standard
- **Distributed Architecture**: Run agent tools separately from consuming applications

### Basic MCP Server Example

```typescript
import { createMcpServer } from "@iqai/adk";

// Define your custom ADK-TS tools
class CustomAnalysisTool {
  name = "analyze_document";
  description = "Analyzes a document and extracts key insights";

  async execute(args: { content: string }) {
    // Your analysis logic
    return {
      summary: "Key findings...",
      topics: ["topic1", "topic2"],
      sentiment: "positive",
    };
  }
}

// Create MCP server from ADK-TS tools
const mcpServer = createMcpServer({
  name: "ADK-TS Analysis Server",
  description: "Exposes ADK-TS analysis tools via MCP protocol",
  tools: [new CustomAnalysisTool()],
});

// Start server with stdio transport (local process communication)
await mcpServer.start({
  transport: {
    mode: "stdio",
  },
});
```

### Production MCP Server Pattern

For production deployments, use SSE (Server-Sent Events) for better scalability:

```typescript
import { createMcpServer } from "@iqai/adk";

const mcpServer = createMcpServer({
  name: "Production Tool Server",
  description: "Production MCP server exposing ADK-TS tools",
  tools: [new DocumentAnalyzer(), new DataProcessor(), new ReportGenerator()],
});

// Start with SSE for production (HTTP-based, scalable)
await mcpServer.start({
  transport: {
    mode: "sse",
    port: 8080,
    host: "0.0.0.0",
  },
});

// Now other applications can connect to:
// https://your-domain.com:8080/mcp
```

### Using Your MCP Server in an ADK-TS Agent

Once your MCP server is running, you can consume it in another ADK-TS agent:

```typescript
import { McpToolset, LlmAgent } from "@iqai/adk";

// Connect to your MCP server
const localServerTools = new McpToolset({
  name: "Local Analysis Server",
  description: "Connects to local MCP server",
  transport: {
    mode: "stdio",
    command: "node",
    args: ["./my-mcp-server.js"],
  },
});

const tools = await localServerTools.getTools();

// Use in your agent
const agent = new LlmAgent({
  name: "analysis_agent",
  model: "gemini-2.5-flash",
  instruction: "Use the analysis tools to process and understand documents.",
  tools,
});

const result = await agent.ask("Analyze this document and provide insights");
```

## Best Practices

<Callout type="warn" title="Resource Management">
  Always close MCP toolsets and connections when done to prevent memory leaks
  and zombie processes.
</Callout>

### 1. Resource Cleanup

Properly manage the lifecycle of MCP connections to prevent resource leaks. Always use try/finally blocks to ensure cleanup happens regardless of success or failure.

**Code Example:**

```typescript
import { McpToolset, LlmAgent } from "@iqai/adk";

const toolset = McpAtp({
  env: {
    ATP_WALLET_PRIVATE_KEY: process.env.WALLET_PRIVATE_KEY,
    ATP_API_KEY: process.env.ATP_API_KEY,
  },
});

try {
  const tools = await toolset.getTools();

  const agent = new LlmAgent({
    name: "assistant",
    model: "gemini-2.5-flash",
    tools,
  });

  const result = await agent.ask("Get token statistics");
  console.log(result);
} catch (error) {
  console.error("Agent execution failed:", error);
  // Handle error appropriately
} finally {
  // Always cleanup, even if errors occur
  await toolset.close();
}
```

### 2. Error Handling and Resilience

Handle different MCP error types gracefully and implement recovery strategies. Check error types to provide appropriate feedback and recovery actions.

**Code Example:**

```typescript
import { McpToolset, McpError, McpErrorType } from "@iqai/adk";

const toolset = new McpToolset(mcpConfig);

try {
  const tools = await toolset.getTools();
  // Use tools with your agent...
} catch (error) {
  if (error instanceof McpError) {
    switch (error.type) {
      case McpErrorType.CONNECTION_ERROR:
        console.error("Cannot connect to MCP server - is it running?");
        console.error("Details:", error.message);
        // Implement fallback: use cached tools or skip MCP integration
        break;

      case McpErrorType.TIMEOUT_ERROR:
        console.error("MCP server request timed out");
        console.error("Consider increasing timeout in McpConfig");
        // Retry with longer timeout or use circuit breaker
        break;

      case McpErrorType.TOOL_EXECUTION_ERROR:
        console.error("Tool execution failed:", error.originalError?.message);
        // Log for monitoring, notify user
        break;

      case McpErrorType.INVALID_SCHEMA_ERROR:
        console.error("Invalid MCP tool schema - incompatible version?");
        // Disable tool or request update
        break;

      default:
        console.error("Unexpected MCP error:", error.message);
    }
  } else {
    console.error("Non-MCP error:", error);
  }
} finally {
  await toolset.close();
}
```

### 3. Tool Filtering and Selection

Load only the tools you need from an MCP server. This improves performance, reduces confusion, and can be used for security by restricting available operations.

**Code Example:**

```typescript
import { McpToolset } from "@iqai/adk";

// Filter by specific tool names (whitelist approach)
const toolset = new McpToolset(mcpConfig, ["read_file", "list_directory"]);

// Or use a function for dynamic filtering (blacklist approach)
const restrictedToolset = new McpToolset(mcpConfig, (tool) => {
  // Only include read operations, exclude write/delete for safety
  return !tool.name.includes("write") && !tool.name.includes("delete");
});

const tools = await toolset.getTools();
console.log(`Loaded ${tools.length} tools from MCP server`);
```

### 4. Development vs Production Configuration

Use different connection strategies for development and production environments. Development prioritizes debugging and simplicity, while production prioritizes reliability and scalability.

**Development Configuration:**

```typescript
import { McpToolset, type McpConfig } from "@iqai/adk";

const devConfig: McpConfig = {
  name: "Dev Server",
  description: "Development MCP server",
  debug: true, // Enable debug logging to see all requests/responses
  timeout: 10000, // 10 seconds - generous for development
  retryOptions: {
    maxRetries: 2,
    initialDelay: 200,
  },
  transport: {
    mode: "stdio", // Use local process for simplicity
    command: "npm",
    args: ["run", "mcp:dev"],
    env: { DEBUG: "true" }, // Pass debug flag to server
  },
};

const devToolset = new McpToolset(devConfig);
const tools = await devToolset.getTools();
```

**Production Configuration:**

```typescript
import { McpToolset, type McpConfig } from "@iqai/adk";

const prodConfig: McpConfig = {
  name: "Production Server",
  description: "Production MCP server",
  debug: false, // Disable debug logging for performance
  timeout: 30000, // 30 seconds - longer for production workloads
  retryOptions: {
    maxRetries: 5, // More retries for resilience
    initialDelay: 500,
    maxDelay: 5000, // Cap retry delay to prevent long waits
  },
  cacheConfig: {
    enabled: true, // Cache tool definitions
    maxAge: 3600000, // Cache for 1 hour
  },
  transport: {
    mode: "sse", // Use HTTP for scalability
    serverUrl: "https://mcp.example.com/api",
    headers: {
      Authorization: `Bearer ${process.env.MCP_TOKEN}`,
      "User-Agent": "ADK-Agent/1.0",
    },
  },
};

const prodToolset = new McpToolset(prodConfig);
const tools = await prodToolset.getTools();
```

### 5. Tool Usage Best Practices

Ensure your agent has clear instructions about available tools, test behavior with different prompts, and monitor execution performance.

**Code Example:**

```typescript
import { LlmAgent } from "@iqai/adk";

const agent = new LlmAgent({
  name: "smart_assistant",
  model: "gemini-2.5-flash",
  instruction: `You have access to blockchain tools from ATP, NEAR, and market data from CoinGecko.
               
               Always use the appropriate tool for each query:
               - ATP tools: for token statistics and agent metrics
               - NEAR tools: for blockchain operations and state queries
               - CoinGecko: for market prices, volume, and trends
               
               Before using a tool, check if you understand the parameters.
               Always verify tool responses make sense before presenting to the user.
               If a tool fails, explain to the user and suggest alternatives.`,
  tools,
});

// Test with various prompts to ensure correct tool usage
const testPrompts = [
  "What's the current ATP token price?",
  "List recent NEAR transactions",
  "Compare Bitcoin and Ethereum market caps",
];

for (const prompt of testPrompts) {
  console.log(`Testing: ${prompt}`);
  const result = await agent.ask(prompt);
  console.log(`Result: ${result}\n`);
}
```

## Troubleshooting

| Issue                    | Cause                                            | Solution                                                                  |
| ------------------------ | ------------------------------------------------ | ------------------------------------------------------------------------- |
| Connection timeout       | MCP server not running or slow startup           | Check server is running, increase `timeout` in McpConfig                  |
| Tool not available       | Tool name doesn't match or filtering excluded it | Verify tool name with `getTools()`, check `tool_filter` parameter         |
| "npx: command not found" | Node.js/npm not installed or not in PATH         | Install Node.js, ensure npm/npx in your $PATH, set env.PATH               |
| Memory leaks             | Connection not closed properly                   | Always use try/finally block, call `toolset.close()`                      |
| Parameter mismatch       | Tool args don't match schema                     | Check McpConfig transport matches server requirements, review tool schema |
| Authentication fails     | Wrong credentials or missing env vars            | Verify API keys, check environment variable names match exactly           |

## Related Topics

<Cards>
  <Card
    title="IQ AI MCP Servers"
    description="Explore IQ AI's suite of MCP server offerings"
    href="/docs/mcp-servers"
  />

{" "}

<Card
  title="🔧 Function Tools"
  description="Create custom ADK-TS tools for MCP integration"
  href="/docs/framework/tools/function-tools"
/>

{" "}

<Card
  title="🔐 Authentication"
  description="Secure MCP connections with proper credential handling"
  href="/docs/framework/tools/authentication"
/>

  <Card
    title="📚 MCP"
    description="Official Model Context Protocol documentation"
    href="https://modelcontextprotocol.io/"
  />
</Cards>
