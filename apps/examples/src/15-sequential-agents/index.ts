import { env } from "node:process";
import { AgentBuilder, LlmAgent } from "@iqai/adk";
import { z } from "zod";

// Code Writer Agent
// Takes the initial specification (from user query) and writes code.
const codeWriterAgent = new LlmAgent({
	name: "CodeWriterAgent",
	model: env.LLM_MODEL,
	disallowTransferToParent: true,
	disallowTransferToPeers: true,
	instruction: `You are a Typescript Code Generator.
Based *only* on the user's request, write Typescript code that fulfills the requirement.
Output *only* the complete Typescript code block, enclosed in triple backticks (\`\`\`typescript ... \`\`\`).
Do not add any other text before or after the code block.`,
	description: "Writes initial Typescript code based on a specification.",
	outputKey: "generated_code",
	// Per-agent schema: we still let it be free-form, but demonstrate schema capability
	outputSchema: z
		.object({ code: z.string().describe("Typescript code block as text") })
		.or(z.string()),
});

// Code Reviewer Agent
// Takes the code generated by the previous agent (read from state) and provides feedback.
const codeReviewerAgent = new LlmAgent({
	name: "CodeReviewerAgent",
	model: env.LLM_MODEL,
	disallowTransferToParent: true,
	disallowTransferToPeers: true,
	instruction: `You are an expert Typescript Code Reviewer.
Your task is to provide constructive feedback on the provided code.

**Code to Review:**
\`\`\`typescript
{generated_code}
\`\`\`

**Review Criteria:**
1.  **Correctness:** Does the code work as intended? Are there logic errors?
2.  **Readability:** Is the code clear and easy to understand? Follows PEP 8 style guidelines?
3.  **Efficiency:** Is the code reasonably efficient? Any obvious performance bottlenecks?
4.  **Edge Cases:** Does the code handle potential edge cases or invalid inputs gracefully?
5.  **Best Practices:** Does the code follow common Typescript best practices?

**Output:**
Provide your feedback as a concise, bulleted list. Focus on the most important points for improvement.
If the code is excellent and requires no changes, simply state: "No major issues found."
Output *only* the review comments or the "No major issues" statement.`,
	description: "Reviews code and provides feedback.",
	outputKey: "review_comments",
	outputSchema: z
		.object({ comments: z.string().describe("Review comments as text") })
		.or(z.string()),
});

// Code Refactorer Agent
// Takes the original code and the review comments (read from state) and refactors the code.
const codeRefactorerAgent = new LlmAgent({
	name: "CodeRefactorerAgent",
	model: env.LLM_MODEL,
	disallowTransferToParent: true,
	disallowTransferToPeers: true,
	instruction: `You are a Typescript Code Refactoring AI.
Your goal is to improve the given Typescript code based on the provided review comments.

  **Original Code:**
  \`\`\`typescript
  {generated_code}
  \`\`\`

  **Review Comments:**
  {review_comments}

**Task:**
Carefully apply the suggestions from the review comments to refactor the original code.
If the review comments state "No major issues found," return the original code unchanged.
Ensure the final code is complete, functional, and includes necessary imports and docstrings.

**Output:**
Output *only* the final, refactored Typescript code block, enclosed in triple backticks (\`\`\`typescript ... \`\`\`).
Do not add any other text before or after the code block.`,
	description: "Refactors code based on review comments.",
	outputKey: "refactored_code",
	outputSchema: z
		.object({ code: z.string().describe("Refactored code block as text") })
		.or(z.string()),
});

// Code Packager Agent
// Reads state and emits a single JSON object as final structured output.
const codePackagerAgent = new LlmAgent({
	name: "CodePackagerAgent",
	model: env.LLM_MODEL,
	disallowTransferToParent: true,
	disallowTransferToPeers: true,
	instruction: `You are a result packager.
Produce ONLY application/json (no markdown) with the following fields:
{
  "generatedCode": string,   // original code block as text
  "reviewComments": string,  // review comments as text
  "refactoredCode": string   // final refactored code block as text
}

Values to use:
- generatedCode: {generated_code}
- reviewComments: {review_comments}
- refactoredCode: {refactored_code}

Do not add any extra keys or text. Output only the JSON object.`,
	description: "Packages pipeline outputs into a single JSON object.",
	outputSchema: z.object({
		generatedCode: z.string(),
		reviewComments: z.string(),
		refactoredCode: z.string(),
	}),
});

async function main() {
	const { runner } = await AgentBuilder.create("root_agent")
		.asSequential([
			codeWriterAgent,
			codeReviewerAgent,
			codeRefactorerAgent,
			codePackagerAgent,
		])
		.withDescription(
			"Executes a sequence of code writing, reviewing, and refactoring.",
		)
		.withModel(env.LLM_MODEL!)
		// .withOutputSchema(
		// 	z.object({
		// 		generatedCode: z
		// 			.string()
		// 			.describe("Original generated code block as text"),
		// 		reviewComments: z.string().describe("Review comments as text"),
		// 		refactoredCode: z.string().describe("Refactored code block as text"),
		// 	}),
		// )
		.withQuickSession()
		.build();

	const userRequest =
		"Write a Typescript function fibonacci(n) that returns the n-th Fibonacci number with basic input validation.";
	const response = await runner.ask(userRequest);
	console.log(response);
}

main().catch(console.error);
